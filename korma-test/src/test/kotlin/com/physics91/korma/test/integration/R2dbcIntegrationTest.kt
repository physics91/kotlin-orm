package com.physics91.korma.test.integration

import com.physics91.korma.dialect.h2.H2Dialect
import com.physics91.korma.dsl.*
import com.physics91.korma.r2dbc.R2dbcConnectionFactory
import com.physics91.korma.r2dbc.R2dbcDatabase
import com.physics91.korma.schema.Table
import kotlinx.coroutines.flow.toList
import kotlinx.coroutines.runBlocking
import org.junit.jupiter.api.AfterEach
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import kotlin.test.assertEquals
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

/**
 * Integration tests for R2DBC reactive database operations.
 * Tests streaming, reactive transactions, and non-blocking operations.
 */
class R2dbcIntegrationTest {

    private lateinit var database: R2dbcDatabase

    object Products : Table("products") {
        val id = long("id").primaryKey().autoIncrement()
        val name = varchar("name", 100)
        val price = decimal("price", 10, 2)
        val quantity = integer("quantity")
        val active = boolean("active")
    }

    @BeforeEach
    fun setup() {
        val options = R2dbcConnectionFactory.options()
            .h2Mem("r2dbc_test_${System.nanoTime()}")
            .option("DB_CLOSE_DELAY", "-1")
            .build()

        val factory = R2dbcConnectionFactory.create(
            options,
            R2dbcConnectionFactory.PoolConfig(initialSize = 1, maxSize = 5)
        )

        database = R2dbcDatabase(factory, H2Dialect)

        runBlocking {
            database.execute("""
                CREATE TABLE IF NOT EXISTS "products" (
                    "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                    "name" VARCHAR(100) NOT NULL,
                    "price" DECIMAL(10, 2) NOT NULL,
                    "quantity" INT NOT NULL DEFAULT 0,
                    "active" BOOLEAN NOT NULL DEFAULT TRUE
                )
            """.trimIndent())
        }
    }

    @AfterEach
    fun tearDown() {
        database.close()
    }

    // ==================== Basic R2DBC Operations ====================

    @Test
    fun `insert and fetch single record`() = runBlocking {
        val builder = InsertBuilder(Products).apply {
            set(Products.name, "Widget")
            set(Products.price, java.math.BigDecimal("9.99"))
            set(Products.quantity, 100)
            set(Products.active, true)
        }
        database.insert(builder)

        val products = database.select(SelectBuilder(Products)) { row ->
            mapOf(
                "id" to row.get("id", java.lang.Long::class.java),
                "name" to row.get("name", String::class.java),
                "price" to row.get("price", java.math.BigDecimal::class.java),
                "quantity" to row.get("quantity", java.lang.Integer::class.java),
                "active" to row.get("active", java.lang.Boolean::class.java)
            )
        }

        assertEquals(1, products.size)
        assertEquals("Widget", products.first()["name"])
    }

    @Test
    fun `streaming large result set with Flow`() = runBlocking {
        // Insert many records
        repeat(100) { i ->
            val builder = InsertBuilder(Products).apply {
                set(Products.name, "Product_$i")
                set(Products.price, java.math.BigDecimal("${i + 1}.99"))
                set(Products.quantity, i * 10)
                set(Products.active, i % 2 == 0)
            }
            database.insert(builder)
        }

        // Stream results using Flow
        val flow = database.selectFlow(
            SelectBuilder(Products).orderBy(Products.id.asc())
        ) { row ->
            mapOf(
                "id" to row.get("id", java.lang.Long::class.java),
                "name" to row.get("name", String::class.java)
            )
        }

        val products = flow.toList()
        assertEquals(100, products.size)
        assertEquals("Product_0", products.first()["name"])
        assertEquals("Product_99", products.last()["name"])
    }

    @Test
    fun `reactive transaction commit`() = runBlocking {
        database.transaction {
            val builder = InsertBuilder(Products).apply {
                set(Products.name, "Transacted Product")
                set(Products.price, java.math.BigDecimal("29.99"))
                set(Products.quantity, 50)
                set(Products.active, true)
            }
            executor.execute(builder.build(dialect!!).sql, builder.build(dialect!!).params)
        }

        val products = database.select(
            SelectBuilder(Products).where { Products.name eq "Transacted Product" }
        ) { row ->
            mapOf(
                "name" to row.get("name", String::class.java),
                "price" to row.get("price", java.math.BigDecimal::class.java)
            )
        }

        assertNotNull(products.firstOrNull())
        assertEquals(java.math.BigDecimal("29.99"), products.first()["price"])
    }

    @Test
    fun `reactive transaction rollback`() = runBlocking {
        try {
            database.transaction {
                val builder = InsertBuilder(Products).apply {
                    set(Products.name, "Should Rollback")
                    set(Products.price, java.math.BigDecimal("19.99"))
                    set(Products.quantity, 10)
                    set(Products.active, true)
                }
                executor.execute(builder.build(dialect!!).sql, builder.build(dialect!!).params)
                throw RuntimeException("Trigger rollback")
            }
        } catch (e: RuntimeException) {
            // Expected
        }

        val products = database.select(
            SelectBuilder(Products).where { Products.name eq "Should Rollback" }
        ) { row ->
            row.get("name", String::class.java)
        }

        assertTrue(products.isEmpty())
    }

    // ==================== Query Operations ====================

    @Test
    fun `where clause with reactive query`() = runBlocking {
        database.insert(InsertBuilder(Products).apply {
            set(Products.name, "Active Product")
            set(Products.price, java.math.BigDecimal("15.00"))
            set(Products.quantity, 20)
            set(Products.active, true)
        })
        database.insert(InsertBuilder(Products).apply {
            set(Products.name, "Inactive Product")
            set(Products.price, java.math.BigDecimal("25.00"))
            set(Products.quantity, 5)
            set(Products.active, false)
        })

        val activeProducts = database.select(
            SelectBuilder(Products).where { Products.active eq true }
        ) { row ->
            row.get("name", String::class.java)
        }

        assertEquals(1, activeProducts.size)
        assertEquals("Active Product", activeProducts.first())
    }

    @Test
    fun `order by and limit with reactive query`() = runBlocking {
        repeat(10) { i ->
            database.insert(InsertBuilder(Products).apply {
                set(Products.name, "Product_${9 - i}")
                set(Products.price, java.math.BigDecimal("${(i + 1) * 10}.00"))
                set(Products.quantity, i * 5)
                set(Products.active, true)
            })
        }

        val top3 = database.select(
            SelectBuilder(Products)
                .orderBy(Products.price.desc())
                .limit(3)
        ) { row ->
            mapOf(
                "name" to row.get("name", String::class.java),
                "price" to row.get("price", java.math.BigDecimal::class.java)
            )
        }

        assertEquals(3, top3.size)
        assertEquals(java.math.BigDecimal("100.00"), top3[0]["price"])
        assertEquals(java.math.BigDecimal("90.00"), top3[1]["price"])
        assertEquals(java.math.BigDecimal("80.00"), top3[2]["price"])
    }

    @Test
    fun `update with reactive database`() = runBlocking {
        database.insert(InsertBuilder(Products).apply {
            set(Products.name, "Update Me")
            set(Products.price, java.math.BigDecimal("10.00"))
            set(Products.quantity, 100)
            set(Products.active, true)
        })

        val updated = database.update(
            UpdateBuilder(Products)
                .set(Products.price, java.math.BigDecimal("15.00"))
                .set(Products.quantity, 150)
                .where { Products.name eq "Update Me" }
        )

        assertEquals(1L, updated)

        val product = database.select(
            SelectBuilder(Products).where { Products.name eq "Update Me" }
        ) { row ->
            mapOf(
                "price" to row.get("price", java.math.BigDecimal::class.java),
                "quantity" to row.get("quantity", java.lang.Integer::class.java)
            )
        }.first()

        assertEquals(java.math.BigDecimal("15.00"), product["price"])
        assertEquals(150, product["quantity"])
    }

    @Test
    fun `delete with reactive database`() = runBlocking {
        database.insert(InsertBuilder(Products).apply {
            set(Products.name, "Delete Me")
            set(Products.price, java.math.BigDecimal("5.00"))
            set(Products.quantity, 10)
            set(Products.active, false)
        })
        database.insert(InsertBuilder(Products).apply {
            set(Products.name, "Keep Me")
            set(Products.price, java.math.BigDecimal("50.00"))
            set(Products.quantity, 100)
            set(Products.active, true)
        })

        val deleted = database.delete(
            DeleteBuilder(Products).where { Products.active eq false }
        )

        assertEquals(1L, deleted)

        val remaining = database.select(SelectBuilder(Products)) { row ->
            row.get("name", String::class.java)
        }
        assertEquals(1, remaining.size)
        assertEquals("Keep Me", remaining.first())
    }

    // ==================== Complex Query Tests ====================

    @Test
    fun `complex filter conditions`() = runBlocking {
        database.insert(InsertBuilder(Products).apply { set(Products.name, "Cheap Active"); set(Products.price, java.math.BigDecimal("5.00")); set(Products.quantity, 100); set(Products.active, true) })
        database.insert(InsertBuilder(Products).apply { set(Products.name, "Expensive Active"); set(Products.price, java.math.BigDecimal("100.00")); set(Products.quantity, 10); set(Products.active, true) })
        database.insert(InsertBuilder(Products).apply { set(Products.name, "Cheap Inactive"); set(Products.price, java.math.BigDecimal("3.00")); set(Products.quantity, 50); set(Products.active, false) })
        database.insert(InsertBuilder(Products).apply { set(Products.name, "Expensive Inactive"); set(Products.price, java.math.BigDecimal("200.00")); set(Products.quantity, 5); set(Products.active, false) })

        val result = database.select(
            SelectBuilder(Products).where { (Products.price gt java.math.BigDecimal("10.00")) and (Products.active eq true) }
        ) { row ->
            row.get("name", String::class.java)
        }

        assertEquals(1, result.size)
        assertEquals("Expensive Active", result.first())
    }

    @Test
    fun `batch operations in transaction`() = runBlocking {
        database.transaction {
            repeat(5) { i ->
                val builder = InsertBuilder(Products).apply {
                    set(Products.name, "Batch Product $i")
                    set(Products.price, java.math.BigDecimal("${(i + 1) * 10}.00"))
                    set(Products.quantity, (i + 1) * 20)
                    set(Products.active, true)
                }
                executor.execute(builder.build(dialect!!).sql, builder.build(dialect!!).params)
            }
        }

        val products = database.select(SelectBuilder(Products)) { row ->
            row.get("name", String::class.java)
        }
        assertEquals(5, products.size)
    }

    // ==================== Null Handling ====================

    @Test
    fun `handle nullable columns`() = runBlocking {
        database.insert(InsertBuilder(Products).apply {
            set(Products.name, "Nullable Test")
            set(Products.price, java.math.BigDecimal("0.00"))
            set(Products.quantity, 0)
            set(Products.active, false)
        })

        val product = database.select(
            SelectBuilder(Products).where { Products.name eq "Nullable Test" }
        ) { row ->
            mapOf(
                "price" to row.get("price", java.math.BigDecimal::class.java),
                "quantity" to row.get("quantity", java.lang.Integer::class.java),
                "active" to row.get("active", java.lang.Boolean::class.java)
            )
        }.first()

        assertEquals(java.math.BigDecimal("0.00"), product["price"])
        assertEquals(0, product["quantity"])
        assertEquals(false, product["active"])
    }

    // ==================== Pool Metrics ====================

    @Test
    fun `pool metrics are available`() = runBlocking {
        // Just check the metrics are available
        val metrics = database.getPoolMetrics()
        assertNotNull(metrics)
    }
}
