package com.physics91.korma.test.e2e

import com.physics91.korma.dsl.*
import com.physics91.korma.jdbc.JdbcDatabase
import com.physics91.korma.schema.Table
import com.physics91.korma.test.DatabaseTest
import com.physics91.korma.test.DatabaseType
import kotlinx.datetime.Instant
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import kotlin.test.assertEquals
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

/**
 * End-to-end test simulating a blog application scenario.
 * Tests real-world workflows: user registration, post creation, commenting, and content management.
 */
@DatabaseTest(DatabaseType.H2)
class BlogScenarioTest {

    // Domain objects
    data class User(val id: Long, val username: String, val email: String, val createdAt: Instant?)
    data class Post(val id: Long, val authorId: Long, val title: String, val content: String, val published: Boolean, val createdAt: Instant?)
    data class Comment(val id: Long, val postId: Long, val authorId: Long, val content: String, val createdAt: Instant?)
    data class Tag(val id: Long, val name: String)

    // Table definitions
    object Users : Table("blog_users") {
        val id = long("id").primaryKey().autoIncrement()
        val username = varchar("username", 50)
        val email = varchar("email", 100)
        val createdAt = timestamp("created_at").nullable()
    }

    object Posts : Table("blog_posts") {
        val id = long("id").primaryKey().autoIncrement()
        val authorId = long("author_id")
        val title = varchar("title", 200)
        val content = varchar("content", 4000)
        val published = boolean("published")
        val createdAt = timestamp("created_at").nullable()
    }

    object Comments : Table("blog_comments") {
        val id = long("id").primaryKey().autoIncrement()
        val postId = long("post_id")
        val authorId = long("author_id")
        val content = varchar("content", 1000)
        val createdAt = timestamp("created_at").nullable()
    }

    object Tags : Table("blog_tags") {
        val id = long("id").primaryKey().autoIncrement()
        val name = varchar("name", 50)
    }

    object PostTags : Table("blog_post_tags") {
        val postId = long("post_id")
        val tagId = long("tag_id")
    }

    @BeforeEach
    fun setup(database: JdbcDatabase) {
        database.executeRaw("""
            CREATE TABLE IF NOT EXISTS "blog_users" (
                "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "username" VARCHAR(50) NOT NULL UNIQUE,
                "email" VARCHAR(100) NOT NULL,
                "created_at" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """.trimIndent())

        database.executeRaw("""
            CREATE TABLE IF NOT EXISTS "blog_posts" (
                "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "author_id" BIGINT NOT NULL,
                "title" VARCHAR(200) NOT NULL,
                "content" VARCHAR(4000) NOT NULL,
                "published" BOOLEAN NOT NULL DEFAULT FALSE,
                "created_at" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """.trimIndent())

        database.executeRaw("""
            CREATE TABLE IF NOT EXISTS "blog_comments" (
                "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "post_id" BIGINT NOT NULL,
                "author_id" BIGINT NOT NULL,
                "content" VARCHAR(1000) NOT NULL,
                "created_at" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """.trimIndent())

        database.executeRaw("""
            CREATE TABLE IF NOT EXISTS "blog_tags" (
                "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "name" VARCHAR(50) NOT NULL UNIQUE
            )
        """.trimIndent())

        database.executeRaw("""
            CREATE TABLE IF NOT EXISTS "blog_post_tags" (
                "post_id" BIGINT NOT NULL,
                "tag_id" BIGINT NOT NULL,
                PRIMARY KEY ("post_id", "tag_id")
            )
        """.trimIndent())

        // Clean up
        database.executeRaw("""DELETE FROM "blog_post_tags"""")
        database.executeRaw("""DELETE FROM "blog_comments"""")
        database.executeRaw("""DELETE FROM "blog_posts"""")
        database.executeRaw("""DELETE FROM "blog_tags"""")
        database.executeRaw("""DELETE FROM "blog_users"""")
    }

    private fun mapUser(row: com.physics91.korma.jdbc.Row): User = User(
        id = row[Users.id]!!,
        username = row[Users.username]!!,
        email = row[Users.email]!!,
        createdAt = row[Users.createdAt]
    )

    private fun mapPost(row: com.physics91.korma.jdbc.Row): Post = Post(
        id = row[Posts.id]!!,
        authorId = row[Posts.authorId]!!,
        title = row[Posts.title]!!,
        content = row[Posts.content]!!,
        published = row[Posts.published]!!,
        createdAt = row[Posts.createdAt]
    )

    private fun mapComment(row: com.physics91.korma.jdbc.Row): Comment = Comment(
        id = row[Comments.id]!!,
        postId = row[Comments.postId]!!,
        authorId = row[Comments.authorId]!!,
        content = row[Comments.content]!!,
        createdAt = row[Comments.createdAt]
    )

    // ==================== Scenario: User Registration and Profile ====================

    @Test
    fun `complete user registration flow`(database: JdbcDatabase) {
        // Register new user
        val userId = database.transaction {
            insertInto(Users) {
                set(Users.username, "johndoe")
                set(Users.email, "john@example.com")
            }.executeAndGetId()
        }

        assertNotNull(userId)

        // Verify user exists
        val user = database.transaction {
            from(Users)
                .where { Users.id eq userId }
                .fetchFirst { mapUser(it) }
        }

        assertNotNull(user)
        assertEquals("johndoe", user.username)
        assertEquals("john@example.com", user.email)
    }

    // ==================== Scenario: Blog Post Lifecycle ====================

    @Test
    fun `complete blog post lifecycle`(database: JdbcDatabase) {
        // Step 1: Create author
        val authorId = database.transaction {
            insertInto(Users) {
                set(Users.username, "author1")
                set(Users.email, "author@blog.com")
            }.executeAndGetId()
        }

        // Step 2: Create draft post
        val postId = database.transaction {
            insertInto(Posts) {
                set(Posts.authorId, authorId)
                set(Posts.title, "My First Post")
                set(Posts.content, "This is the content of my first blog post.")
                set(Posts.published, false)
            }.executeAndGetId()
        }

        // Verify draft status
        var post = database.transaction {
            from(Posts).where { Posts.id eq postId }.fetchFirst { mapPost(it) }
        }!!
        assertEquals(false, post.published)

        // Step 3: Publish the post
        database.transaction {
            update(Posts)
                .set(Posts.published, true)
                .where { Posts.id eq postId }
                .execute()
        }

        // Verify published status
        post = database.transaction {
            from(Posts).where { Posts.id eq postId }.fetchFirst { mapPost(it) }
        }!!
        assertEquals(true, post.published)

        // Step 4: Update post content
        database.transaction {
            update(Posts)
                .set(Posts.title, "My First Post (Updated)")
                .set(Posts.content, "Updated content with more details.")
                .where { Posts.id eq postId }
                .execute()
        }

        post = database.transaction {
            from(Posts).where { Posts.id eq postId }.fetchFirst { mapPost(it) }
        }!!
        assertEquals("My First Post (Updated)", post.title)
    }

    // ==================== Scenario: Comment System ====================

    @Test
    fun `comment thread on blog post`(database: JdbcDatabase) {
        // Setup: Create author and reader
        val authorId = database.transaction {
            insertInto(Users) { set(Users.username, "blogger"); set(Users.email, "blog@test.com") }.executeAndGetId()
        }
        val readerId = database.transaction {
            insertInto(Users) { set(Users.username, "reader"); set(Users.email, "reader@test.com") }.executeAndGetId()
        }

        // Create post
        val postId = database.transaction {
            insertInto(Posts) {
                set(Posts.authorId, authorId)
                set(Posts.title, "Discussion Topic")
                set(Posts.content, "Let's discuss this topic.")
                set(Posts.published, true)
            }.executeAndGetId()
        }

        // Add comments
        database.transaction {
            insertInto(Comments) {
                set(Comments.postId, postId)
                set(Comments.authorId, readerId)
                set(Comments.content, "Great post!")
            }.execute()

            insertInto(Comments) {
                set(Comments.postId, postId)
                set(Comments.authorId, authorId)
                set(Comments.content, "Thanks for reading!")
            }.execute()

            insertInto(Comments) {
                set(Comments.postId, postId)
                set(Comments.authorId, readerId)
                set(Comments.content, "Looking forward to more content.")
            }.execute()
        }

        // Verify comments
        val comments = database.transaction {
            from(Comments)
                .where { Comments.postId eq postId }
                .orderBy(Comments.id.asc())
                .fetch { mapComment(it) }
        }

        assertEquals(3, comments.size)
        assertEquals("Great post!", comments[0].content)
        assertEquals(readerId, comments[0].authorId)
    }

    // ==================== Scenario: Tag System ====================

    @Test
    fun `tagging and filtering posts`(database: JdbcDatabase) {
        // Setup users and tags
        val authorId = database.transaction {
            insertInto(Users) { set(Users.username, "tagger"); set(Users.email, "tagger@test.com") }.executeAndGetId()
        }

        val kotlinTagId = database.transaction {
            insertInto(Tags) { set(Tags.name, "kotlin") }.executeAndGetId()
        }
        val javaTagId = database.transaction {
            insertInto(Tags) { set(Tags.name, "java") }.executeAndGetId()
        }
        val programmingTagId = database.transaction {
            insertInto(Tags) { set(Tags.name, "programming") }.executeAndGetId()
        }

        // Create posts with tags
        val kotlinPostId = database.transaction {
            val id = insertInto(Posts) {
                set(Posts.authorId, authorId)
                set(Posts.title, "Kotlin Tutorial")
                set(Posts.content, "Learn Kotlin basics.")
                set(Posts.published, true)
            }.executeAndGetId()

            insertInto(PostTags) { set(PostTags.postId, id); set(PostTags.tagId, kotlinTagId) }.execute()
            insertInto(PostTags) { set(PostTags.postId, id); set(PostTags.tagId, programmingTagId) }.execute()
            id
        }

        val javaPostId = database.transaction {
            val id = insertInto(Posts) {
                set(Posts.authorId, authorId)
                set(Posts.title, "Java Guide")
                set(Posts.content, "Learn Java basics.")
                set(Posts.published, true)
            }.executeAndGetId()

            insertInto(PostTags) { set(PostTags.postId, id); set(PostTags.tagId, javaTagId) }.execute()
            insertInto(PostTags) { set(PostTags.postId, id); set(PostTags.tagId, programmingTagId) }.execute()
            id
        }

        // Find posts by tag (using subquery simulation with IN)
        val kotlinPosts = database.transaction {
            val kotlinTaggedPostIds = from(PostTags)
                .where { PostTags.tagId eq kotlinTagId }
                .fetch { row -> row[PostTags.postId]!! }

            from(Posts)
                .where { Posts.id inList kotlinTaggedPostIds }
                .fetch { mapPost(it) }
        }

        assertEquals(1, kotlinPosts.size)
        assertEquals("Kotlin Tutorial", kotlinPosts[0].title)

        // Find all programming posts
        val programmingPosts = database.transaction {
            val programmingPostIds = from(PostTags)
                .where { PostTags.tagId eq programmingTagId }
                .fetch { row -> row[PostTags.postId]!! }

            from(Posts)
                .where { Posts.id inList programmingPostIds }
                .fetch { mapPost(it) }
        }

        assertEquals(2, programmingPosts.size)
    }

    // ==================== Scenario: Content Search and Pagination ====================

    @Test
    fun `search and paginate blog posts`(database: JdbcDatabase) {
        val authorId = database.transaction {
            insertInto(Users) { set(Users.username, "prolific"); set(Users.email, "prolific@test.com") }.executeAndGetId()
        }

        // Create many posts
        database.transaction {
            repeat(25) { i ->
                insertInto(Posts) {
                    set(Posts.authorId, authorId)
                    set(Posts.title, "Post #${i + 1}: ${if (i % 3 == 0) "Kotlin" else "Java"} Topic")
                    set(Posts.content, "Content for post ${i + 1}")
                    set(Posts.published, true)
                }.execute()
            }
        }

        // Test pagination - page 1
        val page1 = database.transaction {
            from(Posts)
                .orderBy(Posts.id.asc())
                .limit(10)
                .offset(0)
                .fetch { mapPost(it) }
        }
        assertEquals(10, page1.size)
        assertEquals("Post #1: Kotlin Topic", page1[0].title)

        // Test pagination - page 2
        val page2 = database.transaction {
            from(Posts)
                .orderBy(Posts.id.asc())
                .limit(10)
                .offset(10)
                .fetch { mapPost(it) }
        }
        assertEquals(10, page2.size)
        assertEquals("Post #11: Java Topic", page2[0].title)

        // Test search by title pattern
        val kotlinPosts = database.transaction {
            from(Posts)
                .where { Posts.title like "%Kotlin%" }
                .fetch { mapPost(it) }
        }
        assertEquals(9, kotlinPosts.size) // Posts 1, 4, 7, 10, 13, 16, 19, 22, 25
    }

    // ==================== Scenario: User Activity Statistics ====================

    @Test
    fun `calculate user activity statistics`(database: JdbcDatabase) {
        // Create users
        val activeUserId = database.transaction {
            insertInto(Users) { set(Users.username, "active_user"); set(Users.email, "active@test.com") }.executeAndGetId()
        }
        val casualUserId = database.transaction {
            insertInto(Users) { set(Users.username, "casual_user"); set(Users.email, "casual@test.com") }.executeAndGetId()
        }

        // Active user creates many posts
        database.transaction {
            repeat(10) { i ->
                insertInto(Posts) {
                    set(Posts.authorId, activeUserId)
                    set(Posts.title, "Active Post $i")
                    set(Posts.content, "Content")
                    set(Posts.published, true)
                }.execute()
            }
        }

        // Casual user creates few posts
        database.transaction {
            repeat(2) { i ->
                insertInto(Posts) {
                    set(Posts.authorId, casualUserId)
                    set(Posts.title, "Casual Post $i")
                    set(Posts.content, "Content")
                    set(Posts.published, true)
                }.execute()
            }
        }

        // Count posts per user
        val activePostCount = database.transaction {
            from(Posts).where { Posts.authorId eq activeUserId }.count()
        }
        val casualPostCount = database.transaction {
            from(Posts).where { Posts.authorId eq casualUserId }.count()
        }

        assertEquals(10L, activePostCount)
        assertEquals(2L, casualPostCount)

        // Find most active users (users with more than 5 posts)
        val activeUsers = database.transaction {
            val activeAuthorIds = from(Posts)
                .fetch { row -> row[Posts.authorId]!! }
                .groupingBy { it }
                .eachCount()
                .filter { it.value > 5 }
                .keys
                .toList()

            from(Users)
                .where { Users.id inList activeAuthorIds }
                .fetch { mapUser(it) }
        }

        assertEquals(1, activeUsers.size)
        assertEquals("active_user", activeUsers[0].username)
    }

    // ==================== Scenario: Draft Management ====================

    @Test
    fun `manage draft posts workflow`(database: JdbcDatabase) {
        val authorId = database.transaction {
            insertInto(Users) { set(Users.username, "writer"); set(Users.email, "writer@test.com") }.executeAndGetId()
        }

        // Create drafts
        database.transaction {
            repeat(5) { i ->
                insertInto(Posts) {
                    set(Posts.authorId, authorId)
                    set(Posts.title, "Draft $i")
                    set(Posts.content, "Draft content $i")
                    set(Posts.published, false)
                }.execute()
            }
        }

        // Create published posts
        database.transaction {
            repeat(3) { i ->
                insertInto(Posts) {
                    set(Posts.authorId, authorId)
                    set(Posts.title, "Published $i")
                    set(Posts.content, "Published content $i")
                    set(Posts.published, true)
                }.execute()
            }
        }

        // Get drafts count
        val draftCount = database.transaction {
            from(Posts)
                .where { (Posts.authorId eq authorId) and (Posts.published eq false) }
                .count()
        }
        assertEquals(5L, draftCount)

        // Publish all drafts
        val publishedCount = database.transaction {
            update(Posts)
                .set(Posts.published, true)
                .where { (Posts.authorId eq authorId) and (Posts.published eq false) }
                .execute()
        }
        assertEquals(5, publishedCount)

        // Verify all published
        val remainingDrafts = database.transaction {
            from(Posts)
                .where { Posts.published eq false }
                .count()
        }
        assertEquals(0L, remainingDrafts)
    }

    // ==================== Scenario: Content Cleanup ====================

    @Test
    fun `delete post and cascade comments`(database: JdbcDatabase) {
        val authorId = database.transaction {
            insertInto(Users) { set(Users.username, "cleanup"); set(Users.email, "cleanup@test.com") }.executeAndGetId()
        }

        val postId = database.transaction {
            insertInto(Posts) {
                set(Posts.authorId, authorId)
                set(Posts.title, "To Be Deleted")
                set(Posts.content, "This will be deleted")
                set(Posts.published, true)
            }.executeAndGetId()
        }

        // Add comments
        database.transaction {
            repeat(5) {
                insertInto(Comments) {
                    set(Comments.postId, postId)
                    set(Comments.authorId, authorId)
                    set(Comments.content, "Comment $it")
                }.execute()
            }
        }

        // Verify comments exist
        var commentCount = database.transaction {
            from(Comments).where { Comments.postId eq postId }.count()
        }
        assertEquals(5L, commentCount)

        // Delete post and its comments (manual cascade)
        database.transaction {
            deleteFrom(Comments).where { Comments.postId eq postId }.execute()
            deleteFrom(Posts).where { Posts.id eq postId }.execute()
        }

        // Verify cleanup
        val postExists = database.transaction {
            from(Posts).where { Posts.id eq postId }.exists()
        }
        commentCount = database.transaction {
            from(Comments).where { Comments.postId eq postId }.count()
        }

        assertTrue(!postExists)
        assertEquals(0L, commentCount)
    }
}
