package com.physics91.korma.test.stress

import com.physics91.korma.dsl.*
import com.physics91.korma.jdbc.JdbcDatabase
import com.physics91.korma.schema.Table
import com.physics91.korma.test.DatabaseTest
import com.physics91.korma.test.DatabaseType
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import java.util.concurrent.CountDownLatch
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicInteger
import kotlin.test.assertEquals
import kotlin.test.assertTrue

/**
 * Stress tests for connection pool behavior under heavy load.
 * Tests connection acquisition, release, and pool exhaustion scenarios.
 */
@DatabaseTest(DatabaseType.H2)
class ConnectionPoolStressTest {

    object TestItems : Table("stress_items") {
        val id = long("id").primaryKey().autoIncrement()
        val name = varchar("name", 100)
        val value = integer("value")
    }

    @BeforeEach
    fun setup(database: JdbcDatabase) {
        database.executeRaw("""
            CREATE TABLE IF NOT EXISTS "stress_items" (
                "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "name" VARCHAR(100) NOT NULL,
                "value" INT NOT NULL DEFAULT 0
            )
        """.trimIndent())
        database.executeRaw("""DELETE FROM "stress_items"""")
    }

    @Test
    fun `high concurrency connection acquisition`(database: JdbcDatabase) {
        val threadCount = 50
        val operationsPerThread = 100
        val latch = CountDownLatch(threadCount)
        val executor = Executors.newFixedThreadPool(threadCount)
        val successCount = AtomicInteger(0)
        val failureCount = AtomicInteger(0)

        repeat(threadCount) { threadId ->
            executor.submit {
                try {
                    repeat(operationsPerThread) { opId ->
                        try {
                            database.transaction {
                                insertInto(TestItems) {
                                    set(TestItems.name, "item_${threadId}_$opId")
                                    set(TestItems.value, threadId * 1000 + opId)
                                }.execute()
                            }
                            successCount.incrementAndGet()
                        } catch (e: Exception) {
                            failureCount.incrementAndGet()
                        }
                    }
                } finally {
                    latch.countDown()
                }
            }
        }

        assertTrue(latch.await(60, TimeUnit.SECONDS), "All threads should complete within timeout")
        executor.shutdown()

        val totalOperations = threadCount * operationsPerThread
        val actualCount = database.transaction {
            from(TestItems).count()
        }

        // All successful inserts should be in the database
        assertEquals(successCount.get().toLong(), actualCount)
        assertTrue(successCount.get() > totalOperations * 0.95, "At least 95% of operations should succeed")
    }

    @Test
    fun `rapid connection acquire and release`(database: JdbcDatabase) {
        val iterations = 1000
        val successCount = AtomicInteger(0)

        repeat(iterations) { i ->
            try {
                database.transaction {
                    from(TestItems).count()
                }
                successCount.incrementAndGet()
            } catch (e: Exception) {
                // Log but continue
            }
        }

        assertTrue(successCount.get() >= iterations * 0.99, "At least 99% of rapid connections should succeed")
    }

    @Test
    fun `mixed read and write under load`(database: JdbcDatabase) {
        // Pre-populate with some data
        database.transaction {
            repeat(100) { i ->
                insertInto(TestItems) {
                    set(TestItems.name, "initial_$i")
                    set(TestItems.value, i)
                }.execute()
            }
        }

        val threadCount = 20
        val operationsPerThread = 50
        val latch = CountDownLatch(threadCount)
        val executor = Executors.newFixedThreadPool(threadCount)
        val readSuccess = AtomicInteger(0)
        val writeSuccess = AtomicInteger(0)

        repeat(threadCount) { threadId ->
            executor.submit {
                try {
                    repeat(operationsPerThread) { opId ->
                        try {
                            if (opId % 3 == 0) {
                                // Write operation
                                database.transaction {
                                    insertInto(TestItems) {
                                        set(TestItems.name, "new_${threadId}_$opId")
                                        set(TestItems.value, threadId * 1000 + opId)
                                    }.execute()
                                }
                                writeSuccess.incrementAndGet()
                            } else {
                                // Read operation
                                database.transaction {
                                    from(TestItems)
                                        .where { TestItems.value gt 0 }
                                        .limit(10)
                                        .fetch { row -> row[TestItems.name] }
                                }
                                readSuccess.incrementAndGet()
                            }
                        } catch (e: Exception) {
                            // Continue on individual failures
                        }
                    }
                } finally {
                    latch.countDown()
                }
            }
        }

        assertTrue(latch.await(60, TimeUnit.SECONDS), "All threads should complete")
        executor.shutdown()

        assertTrue(readSuccess.get() > 0, "Should have successful reads")
        assertTrue(writeSuccess.get() > 0, "Should have successful writes")
    }

    @Test
    fun `long running transactions with short transactions`(database: JdbcDatabase) {
        val longTransactionLatch = CountDownLatch(1)
        val shortTransactionsLatch = CountDownLatch(50)
        val executor = Executors.newFixedThreadPool(51)
        val shortSuccessCount = AtomicInteger(0)

        // Start a long-running transaction
        executor.submit {
            try {
                database.transaction {
                    insertInto(TestItems) {
                        set(TestItems.name, "long_running")
                        set(TestItems.value, 999)
                    }.execute()

                    // Simulate long-running work
                    Thread.sleep(2000)

                    insertInto(TestItems) {
                        set(TestItems.name, "long_running_end")
                        set(TestItems.value, 1000)
                    }.execute()
                }
            } finally {
                longTransactionLatch.countDown()
            }
        }

        // Start many short transactions concurrently
        Thread.sleep(100) // Let the long transaction start

        repeat(50) { i ->
            executor.submit {
                try {
                    database.transaction {
                        insertInto(TestItems) {
                            set(TestItems.name, "short_$i")
                            set(TestItems.value, i)
                        }.execute()
                    }
                    shortSuccessCount.incrementAndGet()
                } finally {
                    shortTransactionsLatch.countDown()
                }
            }
        }

        assertTrue(shortTransactionsLatch.await(30, TimeUnit.SECONDS), "Short transactions should complete")
        assertTrue(longTransactionLatch.await(30, TimeUnit.SECONDS), "Long transaction should complete")
        executor.shutdown()

        // Verify data integrity
        val totalCount = database.transaction {
            from(TestItems).count()
        }

        assertTrue(totalCount >= 50, "At least short transactions should succeed")
    }

    @Test
    fun `burst traffic pattern`(database: JdbcDatabase) {
        val burstCount = 5
        val requestsPerBurst = 100
        val totalSuccess = AtomicInteger(0)

        repeat(burstCount) { burst ->
            val latch = CountDownLatch(requestsPerBurst)
            val executor = Executors.newFixedThreadPool(requestsPerBurst)

            repeat(requestsPerBurst) { i ->
                executor.submit {
                    try {
                        database.transaction {
                            insertInto(TestItems) {
                                set(TestItems.name, "burst${burst}_item$i")
                                set(TestItems.value, burst * 1000 + i)
                            }.execute()
                        }
                        totalSuccess.incrementAndGet()
                    } finally {
                        latch.countDown()
                    }
                }
            }

            assertTrue(latch.await(30, TimeUnit.SECONDS), "Burst $burst should complete")
            executor.shutdown()

            // Small pause between bursts
            Thread.sleep(100)
        }

        val finalCount = database.transaction {
            from(TestItems).count()
        }

        assertEquals(totalSuccess.get().toLong(), finalCount)
        assertTrue(totalSuccess.get() >= burstCount * requestsPerBurst * 0.9, "At least 90% of burst requests should succeed")
    }
}
