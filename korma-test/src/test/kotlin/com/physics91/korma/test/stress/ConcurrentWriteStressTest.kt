package com.physics91.korma.test.stress

import com.physics91.korma.dsl.*
import com.physics91.korma.jdbc.JdbcDatabase
import com.physics91.korma.schema.Table
import com.physics91.korma.test.DatabaseTest
import com.physics91.korma.test.DatabaseType
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import java.math.BigDecimal
import java.util.concurrent.CountDownLatch
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicInteger
import java.util.concurrent.atomic.AtomicLong
import kotlin.test.assertEquals
import kotlin.test.assertTrue

/**
 * Stress tests for concurrent write operations.
 * Tests data integrity under high write load.
 */
@DatabaseTest(DatabaseType.H2)
class ConcurrentWriteStressTest {

    data class WriteRecord(val id: Long, val name: String, val counter: Int, val amount: BigDecimal)

    object WriteRecords : Table("write_records") {
        val id = long("id").primaryKey().autoIncrement()
        val name = varchar("name", 100)
        val counter = integer("counter")
        val amount = decimal("amount", 10, 2)
    }

    object Sequences : Table("sequences") {
        val id = long("id").primaryKey().autoIncrement()
        val name = varchar("name", 50)
        val currentValue = long("current_value")
    }

    @BeforeEach
    fun setup(database: JdbcDatabase) {
        database.executeRaw("""
            CREATE TABLE IF NOT EXISTS "write_records" (
                "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "name" VARCHAR(100) NOT NULL,
                "counter" INT NOT NULL DEFAULT 0,
                "amount" DECIMAL(10, 2) NOT NULL DEFAULT 0
            )
        """.trimIndent())

        database.executeRaw("""
            CREATE TABLE IF NOT EXISTS "sequences" (
                "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "name" VARCHAR(50) NOT NULL UNIQUE,
                "current_value" BIGINT NOT NULL DEFAULT 0
            )
        """.trimIndent())

        database.executeRaw("""DELETE FROM "write_records"""")
        database.executeRaw("""DELETE FROM "sequences"""")
    }

    private fun mapWriteRecord(row: com.physics91.korma.jdbc.Row): WriteRecord = WriteRecord(
        id = row[WriteRecords.id]!!,
        name = row[WriteRecords.name]!!,
        counter = row[WriteRecords.counter]!!,
        amount = row[WriteRecords.amount]!!
    )

    @Test
    fun `concurrent batch inserts`(database: JdbcDatabase) {
        val threadCount = 10
        val batchSize = 100
        val latch = CountDownLatch(threadCount)
        val executor = Executors.newFixedThreadPool(threadCount)
        val totalInserted = AtomicInteger(0)

        repeat(threadCount) { threadId ->
            executor.submit {
                try {
                    val items = (0 until batchSize).map { i ->
                        "thread${threadId}_item$i" to (threadId * batchSize + i)
                    }

                    database.transaction {
                        batchInsertInto(WriteRecords, items) { (name, counter) ->
                            set(WriteRecords.name, name)
                            set(WriteRecords.counter, counter)
                            set(WriteRecords.amount, BigDecimal("${counter}.99"))
                        }.execute()
                    }
                    totalInserted.addAndGet(batchSize)
                } finally {
                    latch.countDown()
                }
            }
        }

        assertTrue(latch.await(60, TimeUnit.SECONDS), "All batches should complete")
        executor.shutdown()

        val count = database.transaction {
            from(WriteRecords).count()
        }

        assertEquals((threadCount * batchSize).toLong(), count)
        assertEquals(threadCount * batchSize, totalInserted.get())
    }

    @Test
    fun `concurrent updates on different rows`(database: JdbcDatabase) {
        // Pre-populate records
        val recordIds = database.transaction {
            (0 until 100).map { i ->
                insertInto(WriteRecords) {
                    set(WriteRecords.name, "record_$i")
                    set(WriteRecords.counter, 0)
                    set(WriteRecords.amount, BigDecimal("0.00"))
                }.executeAndGetId()
            }
        }

        val threadCount = 20
        val updatesPerThread = 50
        val latch = CountDownLatch(threadCount)
        val executor = Executors.newFixedThreadPool(threadCount)
        val updateSuccess = AtomicInteger(0)

        repeat(threadCount) { threadId ->
            executor.submit {
                try {
                    repeat(updatesPerThread) { opId ->
                        val recordIndex = (threadId * updatesPerThread + opId) % recordIds.size
                        val recordId = recordIds[recordIndex]

                        database.transaction {
                            val current = from(WriteRecords)
                                .where { WriteRecords.id eq recordId }
                                .fetchFirst { it[WriteRecords.counter]!! }!!

                            update(WriteRecords)
                                .set(WriteRecords.counter, current + 1)
                                .where { WriteRecords.id eq recordId }
                                .execute()
                        }
                        updateSuccess.incrementAndGet()
                    }
                } finally {
                    latch.countDown()
                }
            }
        }

        assertTrue(latch.await(60, TimeUnit.SECONDS), "All updates should complete")
        executor.shutdown()

        // Verify total increments
        val totalCounter = database.transaction {
            from(WriteRecords)
                .fetch { it[WriteRecords.counter]!! }
                .sum()
        }

        // Due to race conditions, total may not equal expected
        assertTrue(totalCounter > 0, "Updates should have occurred")
    }

    @Test
    fun `concurrent sequence increments`(database: JdbcDatabase) {
        // Create sequence
        val seqId = database.transaction {
            insertInto(Sequences) {
                set(Sequences.name, "order_seq")
                set(Sequences.currentValue, 0L)
            }.executeAndGetId()
        }

        val threadCount = 10
        val incrementsPerThread = 100
        val latch = CountDownLatch(threadCount)
        val executor = Executors.newFixedThreadPool(threadCount)
        val obtainedValues = java.util.concurrent.ConcurrentLinkedQueue<Long>()

        repeat(threadCount) {
            executor.submit {
                try {
                    repeat(incrementsPerThread) {
                        val newValue = database.transaction {
                            val current = from(Sequences)
                                .where { Sequences.id eq seqId }
                                .fetchFirst { it[Sequences.currentValue]!! }!!

                            val next = current + 1
                            update(Sequences)
                                .set(Sequences.currentValue, next)
                                .where { Sequences.id eq seqId }
                                .execute()
                            next
                        }
                        obtainedValues.add(newValue)
                    }
                } finally {
                    latch.countDown()
                }
            }
        }

        assertTrue(latch.await(60, TimeUnit.SECONDS), "All increments should complete")
        executor.shutdown()

        // Final value should reflect all operations
        val finalValue = database.transaction {
            from(Sequences)
                .where { Sequences.id eq seqId }
                .fetchFirst { it[Sequences.currentValue]!! }!!
        }

        assertTrue(finalValue > 0, "Sequence should have been incremented")
    }

    @Test
    fun `mixed insert update delete operations`(database: JdbcDatabase) {
        // Pre-populate some data
        database.transaction {
            repeat(50) { i ->
                insertInto(WriteRecords) {
                    set(WriteRecords.name, "initial_$i")
                    set(WriteRecords.counter, i)
                    set(WriteRecords.amount, BigDecimal("$i.00"))
                }.execute()
            }
        }

        val threadCount = 15
        val operationsPerThread = 100
        val latch = CountDownLatch(threadCount)
        val executor = Executors.newFixedThreadPool(threadCount)
        val insertCount = AtomicInteger(0)
        val updateCount = AtomicInteger(0)
        val deleteCount = AtomicInteger(0)

        repeat(threadCount) { threadId ->
            executor.submit {
                try {
                    repeat(operationsPerThread) { opId ->
                        try {
                            when (opId % 3) {
                                0 -> {
                                    // Insert
                                    database.transaction {
                                        insertInto(WriteRecords) {
                                            set(WriteRecords.name, "new_${threadId}_$opId")
                                            set(WriteRecords.counter, opId)
                                            set(WriteRecords.amount, BigDecimal("$opId.50"))
                                        }.execute()
                                    }
                                    insertCount.incrementAndGet()
                                }
                                1 -> {
                                    // Update
                                    database.transaction {
                                        update(WriteRecords)
                                            .set(WriteRecords.counter, opId)
                                            .where { WriteRecords.name like "initial_%" }
                                            .execute()
                                    }
                                    updateCount.incrementAndGet()
                                }
                                2 -> {
                                    // Delete (limited to avoid depleting data)
                                    database.transaction {
                                        deleteFrom(WriteRecords)
                                            .where { (WriteRecords.name like "new_%") and (WriteRecords.counter lt 5) }
                                            .execute()
                                    }
                                    deleteCount.incrementAndGet()
                                }
                            }
                        } catch (e: Exception) {
                            // Continue on errors
                        }
                    }
                } finally {
                    latch.countDown()
                }
            }
        }

        assertTrue(latch.await(90, TimeUnit.SECONDS), "All operations should complete")
        executor.shutdown()

        assertTrue(insertCount.get() > 0, "Inserts should have occurred")
        assertTrue(updateCount.get() > 0, "Updates should have occurred")
        assertTrue(deleteCount.get() > 0, "Deletes should have occurred")

        // Verify data integrity
        val records = database.transaction {
            from(WriteRecords).fetch { mapWriteRecord(it) }
        }

        records.forEach { record ->
            assertTrue(record.name.isNotEmpty(), "All records should have valid names")
        }
    }

    @Test
    fun `high volume single table writes`(database: JdbcDatabase) {
        val totalWrites = 5000
        val threadCount = 20
        val writesPerThread = totalWrites / threadCount
        val latch = CountDownLatch(threadCount)
        val executor = Executors.newFixedThreadPool(threadCount)
        val successCount = AtomicLong(0)
        val startTime = System.currentTimeMillis()

        repeat(threadCount) { threadId ->
            executor.submit {
                try {
                    repeat(writesPerThread) { i ->
                        try {
                            database.transaction {
                                insertInto(WriteRecords) {
                                    set(WriteRecords.name, "high_volume_${threadId}_$i")
                                    set(WriteRecords.counter, i)
                                    set(WriteRecords.amount, BigDecimal("${i % 1000}.00"))
                                }.execute()
                            }
                            successCount.incrementAndGet()
                        } catch (e: Exception) {
                            // Continue on errors
                        }
                    }
                } finally {
                    latch.countDown()
                }
            }
        }

        assertTrue(latch.await(120, TimeUnit.SECONDS), "High volume writes should complete")
        executor.shutdown()

        val endTime = System.currentTimeMillis()
        val duration = endTime - startTime
        val writesPerSecond = (successCount.get() * 1000) / duration

        val finalCount = database.transaction {
            from(WriteRecords).count()
        }

        assertEquals(successCount.get(), finalCount)
        assertTrue(successCount.get() >= totalWrites * 0.95, "At least 95% writes should succeed")

        // Log performance metrics (for informational purposes)
        println("High volume writes: ${successCount.get()} in ${duration}ms (~$writesPerSecond/sec)")
    }

    @Test
    fun `transaction rollback under contention`(database: JdbcDatabase) {
        // Create a record that will be contended
        val recordId = database.transaction {
            insertInto(WriteRecords) {
                set(WriteRecords.name, "contended")
                set(WriteRecords.counter, 0)
                set(WriteRecords.amount, BigDecimal("100.00"))
            }.executeAndGetId()
        }

        val threadCount = 10
        val attemptsPerThread = 20
        val latch = CountDownLatch(threadCount)
        val executor = Executors.newFixedThreadPool(threadCount)
        val successCount = AtomicInteger(0)
        val rollbackCount = AtomicInteger(0)

        repeat(threadCount) { threadId ->
            executor.submit {
                try {
                    repeat(attemptsPerThread) {
                        try {
                            database.transaction {
                                val current = from(WriteRecords)
                                    .where { WriteRecords.id eq recordId }
                                    .fetchFirst { it[WriteRecords.amount]!! }!!

                                // Simulate some work
                                Thread.sleep(5)

                                // Validate business rule
                                if (current < BigDecimal("50.00")) {
                                    throw IllegalStateException("Amount too low")
                                }

                                update(WriteRecords)
                                    .set(WriteRecords.amount, current - BigDecimal("1.00"))
                                    .where { WriteRecords.id eq recordId }
                                    .execute()
                            }
                            successCount.incrementAndGet()
                        } catch (e: IllegalStateException) {
                            rollbackCount.incrementAndGet()
                        } catch (e: Exception) {
                            // Other errors
                        }
                    }
                } finally {
                    latch.countDown()
                }
            }
        }

        assertTrue(latch.await(60, TimeUnit.SECONDS), "All attempts should complete")
        executor.shutdown()

        val finalAmount = database.transaction {
            from(WriteRecords)
                .where { WriteRecords.id eq recordId }
                .fetchFirst { it[WriteRecords.amount]!! }!!
        }

        // Final amount should be consistent
        assertTrue(finalAmount >= BigDecimal("0.00"), "Amount should not be negative")
        assertTrue(successCount.get() > 0, "Some transactions should succeed")
    }
}
