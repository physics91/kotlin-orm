package com.physics91.korma.test.e2e

import com.physics91.korma.dsl.*
import com.physics91.korma.jdbc.JdbcDatabase
import com.physics91.korma.schema.Table
import com.physics91.korma.test.DatabaseTest
import com.physics91.korma.test.DatabaseType
import kotlinx.datetime.Instant
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import java.math.BigDecimal
import kotlin.test.assertEquals
import kotlin.test.assertNotNull
import kotlin.test.assertTrue

/**
 * End-to-end test simulating an e-commerce application scenario.
 * Tests real-world workflows: product catalog, cart, orders, inventory, and transactions.
 */
@DatabaseTest(DatabaseType.H2)
class ECommerceScenarioTest {

    // Domain objects
    data class Customer(val id: Long, val name: String, val email: String, val balance: BigDecimal)
    data class Product(val id: Long, val name: String, val price: BigDecimal, val stock: Int, val active: Boolean)
    data class Order(val id: Long, val customerId: Long, val status: String, val totalAmount: BigDecimal, val createdAt: Instant?)
    data class OrderItem(val id: Long, val orderId: Long, val productId: Long, val quantity: Int, val unitPrice: BigDecimal)
    data class CartItem(val id: Long, val customerId: Long, val productId: Long, val quantity: Int)

    // Table definitions
    object Customers : Table("shop_customers") {
        val id = long("id").primaryKey().autoIncrement()
        val name = varchar("name", 100)
        val email = varchar("email", 100)
        val balance = decimal("balance", 10, 2)
    }

    object Products : Table("shop_products") {
        val id = long("id").primaryKey().autoIncrement()
        val name = varchar("name", 200)
        val price = decimal("price", 10, 2)
        val stock = integer("stock")
        val active = boolean("active")
    }

    object Orders : Table("shop_orders") {
        val id = long("id").primaryKey().autoIncrement()
        val customerId = long("customer_id")
        val status = varchar("status", 20)
        val totalAmount = decimal("total_amount", 10, 2)
        val createdAt = timestamp("created_at").nullable()
    }

    object OrderItems : Table("shop_order_items") {
        val id = long("id").primaryKey().autoIncrement()
        val orderId = long("order_id")
        val productId = long("product_id")
        val quantity = integer("quantity")
        val unitPrice = decimal("unit_price", 10, 2)
    }

    object CartItems : Table("shop_cart_items") {
        val id = long("id").primaryKey().autoIncrement()
        val customerId = long("customer_id")
        val productId = long("product_id")
        val quantity = integer("quantity")
    }

    @BeforeEach
    fun setup(database: JdbcDatabase) {
        database.executeRaw("""
            CREATE TABLE IF NOT EXISTS "shop_customers" (
                "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "name" VARCHAR(100) NOT NULL,
                "email" VARCHAR(100) NOT NULL UNIQUE,
                "balance" DECIMAL(10, 2) NOT NULL DEFAULT 0
            )
        """.trimIndent())

        database.executeRaw("""
            CREATE TABLE IF NOT EXISTS "shop_products" (
                "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "name" VARCHAR(200) NOT NULL,
                "price" DECIMAL(10, 2) NOT NULL,
                "stock" INT NOT NULL DEFAULT 0,
                "active" BOOLEAN NOT NULL DEFAULT TRUE
            )
        """.trimIndent())

        database.executeRaw("""
            CREATE TABLE IF NOT EXISTS "shop_orders" (
                "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "customer_id" BIGINT NOT NULL,
                "status" VARCHAR(20) NOT NULL DEFAULT 'PENDING',
                "total_amount" DECIMAL(10, 2) NOT NULL,
                "created_at" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """.trimIndent())

        database.executeRaw("""
            CREATE TABLE IF NOT EXISTS "shop_order_items" (
                "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "order_id" BIGINT NOT NULL,
                "product_id" BIGINT NOT NULL,
                "quantity" INT NOT NULL,
                "unit_price" DECIMAL(10, 2) NOT NULL
            )
        """.trimIndent())

        database.executeRaw("""
            CREATE TABLE IF NOT EXISTS "shop_cart_items" (
                "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "customer_id" BIGINT NOT NULL,
                "product_id" BIGINT NOT NULL,
                "quantity" INT NOT NULL DEFAULT 1
            )
        """.trimIndent())

        // Clean up
        database.executeRaw("""DELETE FROM "shop_order_items"""")
        database.executeRaw("""DELETE FROM "shop_orders"""")
        database.executeRaw("""DELETE FROM "shop_cart_items"""")
        database.executeRaw("""DELETE FROM "shop_products"""")
        database.executeRaw("""DELETE FROM "shop_customers"""")
    }

    private fun mapCustomer(row: com.physics91.korma.jdbc.Row): Customer = Customer(
        id = row[Customers.id]!!,
        name = row[Customers.name]!!,
        email = row[Customers.email]!!,
        balance = row[Customers.balance]!!
    )

    private fun mapProduct(row: com.physics91.korma.jdbc.Row): Product = Product(
        id = row[Products.id]!!,
        name = row[Products.name]!!,
        price = row[Products.price]!!,
        stock = row[Products.stock]!!,
        active = row[Products.active]!!
    )

    private fun mapOrder(row: com.physics91.korma.jdbc.Row): Order = Order(
        id = row[Orders.id]!!,
        customerId = row[Orders.customerId]!!,
        status = row[Orders.status]!!,
        totalAmount = row[Orders.totalAmount]!!,
        createdAt = row[Orders.createdAt]
    )

    private fun mapOrderItem(row: com.physics91.korma.jdbc.Row): OrderItem = OrderItem(
        id = row[OrderItems.id]!!,
        orderId = row[OrderItems.orderId]!!,
        productId = row[OrderItems.productId]!!,
        quantity = row[OrderItems.quantity]!!,
        unitPrice = row[OrderItems.unitPrice]!!
    )

    // ==================== Scenario: Product Catalog ====================

    @Test
    fun `manage product catalog`(database: JdbcDatabase) {
        // Add products to catalog
        database.transaction {
            insertInto(Products) {
                set(Products.name, "Laptop")
                set(Products.price, BigDecimal("999.99"))
                set(Products.stock, 50)
                set(Products.active, true)
            }.execute()

            insertInto(Products) {
                set(Products.name, "Mouse")
                set(Products.price, BigDecimal("29.99"))
                set(Products.stock, 200)
                set(Products.active, true)
            }.execute()

            insertInto(Products) {
                set(Products.name, "Keyboard")
                set(Products.price, BigDecimal("79.99"))
                set(Products.stock, 100)
                set(Products.active, true)
            }.execute()

            insertInto(Products) {
                set(Products.name, "Old Monitor")
                set(Products.price, BigDecimal("199.99"))
                set(Products.stock, 5)
                set(Products.active, false)
            }.execute()
        }

        // Browse active products
        val activeProducts = database.transaction {
            from(Products)
                .where { Products.active eq true }
                .orderBy(Products.price.asc())
                .fetch { mapProduct(it) }
        }

        assertEquals(3, activeProducts.size)
        assertEquals("Mouse", activeProducts[0].name)
        assertEquals("Keyboard", activeProducts[1].name)
        assertEquals("Laptop", activeProducts[2].name)

        // Search products
        val searchResults = database.transaction {
            from(Products)
                .where { (Products.name like "%top%") and (Products.active eq true) }
                .fetch { mapProduct(it) }
        }

        assertEquals(1, searchResults.size)
        assertEquals("Laptop", searchResults[0].name)
    }

    // ==================== Scenario: Shopping Cart ====================

    @Test
    fun `shopping cart operations`(database: JdbcDatabase) {
        // Setup
        val customerId = database.transaction {
            insertInto(Customers) {
                set(Customers.name, "John Doe")
                set(Customers.email, "john@shop.com")
                set(Customers.balance, BigDecimal("500.00"))
            }.executeAndGetId()
        }

        val laptopId = database.transaction {
            insertInto(Products) {
                set(Products.name, "Laptop")
                set(Products.price, BigDecimal("999.99"))
                set(Products.stock, 10)
                set(Products.active, true)
            }.executeAndGetId()
        }

        val mouseId = database.transaction {
            insertInto(Products) {
                set(Products.name, "Mouse")
                set(Products.price, BigDecimal("29.99"))
                set(Products.stock, 50)
                set(Products.active, true)
            }.executeAndGetId()
        }

        // Add to cart
        database.transaction {
            insertInto(CartItems) {
                set(CartItems.customerId, customerId)
                set(CartItems.productId, laptopId)
                set(CartItems.quantity, 1)
            }.execute()

            insertInto(CartItems) {
                set(CartItems.customerId, customerId)
                set(CartItems.productId, mouseId)
                set(CartItems.quantity, 2)
            }.execute()
        }

        // View cart
        val cartItems = database.transaction {
            from(CartItems)
                .where { CartItems.customerId eq customerId }
                .fetch { row ->
                    Triple(
                        row[CartItems.productId]!!,
                        row[CartItems.quantity]!!,
                        row[CartItems.id]!!
                    )
                }
        }

        assertEquals(2, cartItems.size)

        // Calculate cart total
        val cartTotal = database.transaction {
            val items = from(CartItems)
                .where { CartItems.customerId eq customerId }
                .fetch { row ->
                    val productId = row[CartItems.productId]!!
                    val quantity = row[CartItems.quantity]!!
                    Pair(productId, quantity)
                }

            items.sumOf { (productId, quantity) ->
                val product = from(Products)
                    .where { Products.id eq productId }
                    .fetchFirst { mapProduct(it) }!!
                product.price * BigDecimal(quantity)
            }
        }

        assertEquals(BigDecimal("1059.97"), cartTotal)

        // Update quantity
        database.transaction {
            update(CartItems)
                .set(CartItems.quantity, 3)
                .where { (CartItems.customerId eq customerId) and (CartItems.productId eq mouseId) }
                .execute()
        }

        // Remove item from cart
        database.transaction {
            deleteFrom(CartItems)
                .where { (CartItems.customerId eq customerId) and (CartItems.productId eq laptopId) }
                .execute()
        }

        val remainingItems = database.transaction {
            from(CartItems).where { CartItems.customerId eq customerId }.count()
        }
        assertEquals(1L, remainingItems)
    }

    // ==================== Scenario: Order Checkout ====================

    @Test
    fun `complete checkout process`(database: JdbcDatabase) {
        // Setup customer with balance
        val customerId = database.transaction {
            insertInto(Customers) {
                set(Customers.name, "Rich Customer")
                set(Customers.email, "rich@shop.com")
                set(Customers.balance, BigDecimal("2000.00"))
            }.executeAndGetId()
        }

        // Setup products with stock
        val productId = database.transaction {
            insertInto(Products) {
                set(Products.name, "Premium Headphones")
                set(Products.price, BigDecimal("299.99"))
                set(Products.stock, 20)
                set(Products.active, true)
            }.executeAndGetId()
        }

        // Add to cart
        database.transaction {
            insertInto(CartItems) {
                set(CartItems.customerId, customerId)
                set(CartItems.productId, productId)
                set(CartItems.quantity, 2)
            }.execute()
        }

        // Checkout process (atomic transaction)
        val orderId = database.transaction {
            // Get cart items
            val cartItems = from(CartItems)
                .where { CartItems.customerId eq customerId }
                .fetch { row -> Pair(row[CartItems.productId]!!, row[CartItems.quantity]!!) }

            // Calculate total and validate stock
            var totalAmount = BigDecimal.ZERO
            val orderDetails = cartItems.map { (prodId, qty) ->
                val product = from(Products)
                    .where { Products.id eq prodId }
                    .fetchFirst { mapProduct(it) }!!

                if (product.stock < qty) {
                    throw IllegalStateException("Insufficient stock for ${product.name}")
                }

                totalAmount += product.price * BigDecimal(qty)
                Triple(prodId, qty, product.price)
            }

            // Check customer balance
            val customer = from(Customers)
                .where { Customers.id eq customerId }
                .fetchFirst { mapCustomer(it) }!!

            if (customer.balance < totalAmount) {
                throw IllegalStateException("Insufficient balance")
            }

            // Create order
            val ordId = insertInto(Orders) {
                set(Orders.customerId, customerId)
                set(Orders.status, "CONFIRMED")
                set(Orders.totalAmount, totalAmount)
            }.executeAndGetId()

            // Create order items
            orderDetails.forEach { (prodId, qty, price) ->
                insertInto(OrderItems) {
                    set(OrderItems.orderId, ordId)
                    set(OrderItems.productId, prodId)
                    set(OrderItems.quantity, qty)
                    set(OrderItems.unitPrice, price)
                }.execute()

                // Reduce stock
                val currentStock = from(Products)
                    .where { Products.id eq prodId }
                    .fetchFirst { it[Products.stock]!! }!!

                update(Products)
                    .set(Products.stock, currentStock - qty)
                    .where { Products.id eq prodId }
                    .execute()
            }

            // Deduct from balance
            update(Customers)
                .set(Customers.balance, customer.balance - totalAmount)
                .where { Customers.id eq customerId }
                .execute()

            // Clear cart
            deleteFrom(CartItems)
                .where { CartItems.customerId eq customerId }
                .execute()

            ordId
        }

        // Verify order
        val order = database.transaction {
            from(Orders).where { Orders.id eq orderId }.fetchFirst { mapOrder(it) }
        }!!

        assertEquals("CONFIRMED", order.status)
        assertEquals(BigDecimal("599.98"), order.totalAmount)

        // Verify stock reduced
        val product = database.transaction {
            from(Products).where { Products.id eq productId }.fetchFirst { mapProduct(it) }
        }!!
        assertEquals(18, product.stock)

        // Verify balance deducted
        val customer = database.transaction {
            from(Customers).where { Customers.id eq customerId }.fetchFirst { mapCustomer(it) }
        }!!
        assertEquals(BigDecimal("1400.02"), customer.balance)

        // Verify cart cleared
        val cartCount = database.transaction {
            from(CartItems).where { CartItems.customerId eq customerId }.count()
        }
        assertEquals(0L, cartCount)
    }

    // ==================== Scenario: Insufficient Stock ====================

    @Test
    fun `checkout fails on insufficient stock`(database: JdbcDatabase) {
        val customerId = database.transaction {
            insertInto(Customers) {
                set(Customers.name, "Test Customer")
                set(Customers.email, "test@shop.com")
                set(Customers.balance, BigDecimal("1000.00"))
            }.executeAndGetId()
        }

        val productId = database.transaction {
            insertInto(Products) {
                set(Products.name, "Limited Item")
                set(Products.price, BigDecimal("100.00"))
                set(Products.stock, 2) // Only 2 in stock
                set(Products.active, true)
            }.executeAndGetId()
        }

        // Try to order more than available
        assertThrows<IllegalStateException> {
            database.transaction {
                val product = from(Products)
                    .where { Products.id eq productId }
                    .fetchFirst { mapProduct(it) }!!

                if (product.stock < 5) {
                    throw IllegalStateException("Insufficient stock for ${product.name}")
                }
            }
        }

        // Verify stock unchanged
        val product = database.transaction {
            from(Products).where { Products.id eq productId }.fetchFirst { mapProduct(it) }
        }!!
        assertEquals(2, product.stock)
    }

    // ==================== Scenario: Order Status Workflow ====================

    @Test
    fun `order status workflow`(database: JdbcDatabase) {
        val customerId = database.transaction {
            insertInto(Customers) {
                set(Customers.name, "Workflow Customer")
                set(Customers.email, "workflow@shop.com")
                set(Customers.balance, BigDecimal("100.00"))
            }.executeAndGetId()
        }

        // Create order
        val orderId = database.transaction {
            insertInto(Orders) {
                set(Orders.customerId, customerId)
                set(Orders.status, "PENDING")
                set(Orders.totalAmount, BigDecimal("50.00"))
            }.executeAndGetId()
        }

        // Status transitions
        val statuses = listOf("PENDING", "CONFIRMED", "PROCESSING", "SHIPPED", "DELIVERED")

        for (i in 1 until statuses.size) {
            database.transaction {
                update(Orders)
                    .set(Orders.status, statuses[i])
                    .where { Orders.id eq orderId }
                    .execute()
            }

            val order = database.transaction {
                from(Orders).where { Orders.id eq orderId }.fetchFirst { mapOrder(it) }
            }!!

            assertEquals(statuses[i], order.status)
        }
    }

    // ==================== Scenario: Sales Report ====================

    @Test
    fun `generate sales report`(database: JdbcDatabase) {
        val customerId = database.transaction {
            insertInto(Customers) {
                set(Customers.name, "Regular Customer")
                set(Customers.email, "regular@shop.com")
                set(Customers.balance, BigDecimal("5000.00"))
            }.executeAndGetId()
        }

        // Create multiple orders
        database.transaction {
            insertInto(Orders) {
                set(Orders.customerId, customerId)
                set(Orders.status, "DELIVERED")
                set(Orders.totalAmount, BigDecimal("150.00"))
            }.execute()

            insertInto(Orders) {
                set(Orders.customerId, customerId)
                set(Orders.status, "DELIVERED")
                set(Orders.totalAmount, BigDecimal("250.00"))
            }.execute()

            insertInto(Orders) {
                set(Orders.customerId, customerId)
                set(Orders.status, "CANCELLED")
                set(Orders.totalAmount, BigDecimal("100.00"))
            }.execute()

            insertInto(Orders) {
                set(Orders.customerId, customerId)
                set(Orders.status, "DELIVERED")
                set(Orders.totalAmount, BigDecimal("300.00"))
            }.execute()
        }

        // Total revenue (delivered orders only)
        val deliveredOrders = database.transaction {
            from(Orders)
                .where { Orders.status eq "DELIVERED" }
                .fetch { mapOrder(it) }
        }

        val totalRevenue = deliveredOrders.sumOf { it.totalAmount }
        assertEquals(BigDecimal("700.00"), totalRevenue)
        assertEquals(3, deliveredOrders.size)

        // Order count by status
        val ordersByStatus = database.transaction {
            from(Orders)
                .fetch { row -> row[Orders.status]!! }
                .groupingBy { it }
                .eachCount()
        }

        assertEquals(3, ordersByStatus["DELIVERED"])
        assertEquals(1, ordersByStatus["CANCELLED"])
    }

    // ==================== Scenario: Inventory Management ====================

    @Test
    fun `inventory restock workflow`(database: JdbcDatabase) {
        val productId = database.transaction {
            insertInto(Products) {
                set(Products.name, "Popular Item")
                set(Products.price, BigDecimal("49.99"))
                set(Products.stock, 5)
                set(Products.active, true)
            }.executeAndGetId()
        }

        // Check low stock
        val lowStockProducts = database.transaction {
            from(Products)
                .where { (Products.stock lt 10) and (Products.active eq true) }
                .fetch { mapProduct(it) }
        }

        assertEquals(1, lowStockProducts.size)
        assertEquals("Popular Item", lowStockProducts[0].name)

        // Restock
        database.transaction {
            val current = from(Products)
                .where { Products.id eq productId }
                .fetchFirst { it[Products.stock]!! }!!

            update(Products)
                .set(Products.stock, current + 100)
                .where { Products.id eq productId }
                .execute()
        }

        // Verify restock
        val product = database.transaction {
            from(Products).where { Products.id eq productId }.fetchFirst { mapProduct(it) }
        }!!

        assertEquals(105, product.stock)

        // Check no more low stock
        val lowStockAfter = database.transaction {
            from(Products)
                .where { (Products.stock lt 10) and (Products.active eq true) }
                .count()
        }

        assertEquals(0L, lowStockAfter)
    }

    // ==================== Scenario: Price Update ====================

    @Test
    fun `bulk price update`(database: JdbcDatabase) {
        // Create products
        database.transaction {
            repeat(10) { i ->
                insertInto(Products) {
                    set(Products.name, "Product $i")
                    set(Products.price, BigDecimal("${10 + i}.00"))
                    set(Products.stock, 100)
                    set(Products.active, true)
                }.execute()
            }
        }

        // Apply 10% discount to all active products
        database.transaction {
            val products = from(Products)
                .where { Products.active eq true }
                .fetch { mapProduct(it) }

            products.forEach { product ->
                val newPrice = product.price * BigDecimal("0.90")
                update(Products)
                    .set(Products.price, newPrice.setScale(2, java.math.RoundingMode.HALF_UP))
                    .where { Products.id eq product.id }
                    .execute()
            }
        }

        // Verify prices
        val updatedProducts = database.transaction {
            from(Products)
                .orderBy(Products.id.asc())
                .fetch { mapProduct(it) }
        }

        assertEquals(BigDecimal("9.00"), updatedProducts[0].price)
        assertEquals(BigDecimal("9.90"), updatedProducts[1].price)
    }
}
