package com.physics91.korma.test.integration

import com.physics91.korma.dsl.*
import com.physics91.korma.jdbc.JdbcDatabase
import com.physics91.korma.schema.Table
import com.physics91.korma.test.DatabaseTest
import com.physics91.korma.test.DatabaseType
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import kotlin.test.assertEquals
import kotlin.test.assertNull
import kotlin.test.assertTrue

/**
 * Integration tests for transaction handling.
 * Tests commit, rollback, and nested transaction scenarios.
 */
@DatabaseTest(DatabaseType.H2)
class TransactionIntegrationTest {

    // Data classes for mapping
    data class AccountData(val id: Long, val name: String, val balance: java.math.BigDecimal)
    data class TransferLogData(val id: Long, val fromAccount: Long, val toAccount: Long, val amount: java.math.BigDecimal)

    object Accounts : Table("accounts") {
        val id = long("id").primaryKey().autoIncrement()
        val name = varchar("name", 50)
        val balance = decimal("balance", 10, 2)
    }

    object TransferLog : Table("transfer_log") {
        val id = long("id").primaryKey().autoIncrement()
        val fromAccount = long("from_account")
        val toAccount = long("to_account")
        val amount = decimal("amount", 10, 2)
        val timestamp = timestamp("timestamp")
    }

    @BeforeEach
    fun setup(database: JdbcDatabase) {
        database.executeRaw("""
            CREATE TABLE IF NOT EXISTS "accounts" (
                "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "name" VARCHAR(50) NOT NULL,
                "balance" DECIMAL(10, 2) NOT NULL DEFAULT 0
            )
        """.trimIndent())

        database.executeRaw("""
            CREATE TABLE IF NOT EXISTS "transfer_log" (
                "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "from_account" BIGINT NOT NULL,
                "to_account" BIGINT NOT NULL,
                "amount" DECIMAL(10, 2) NOT NULL,
                "timestamp" TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """.trimIndent())

        database.executeRaw("""DELETE FROM "transfer_log"""")
        database.executeRaw("""DELETE FROM "accounts"""")
    }

    // ==================== Basic Transaction Tests ====================

    @Test
    fun `transaction commits on success`(database: JdbcDatabase) {
        database.transaction {
            insertInto(Accounts) {
                set(Accounts.name, "Test Account")
                set(Accounts.balance, java.math.BigDecimal("100.00"))
            }.execute()
        }

        val account = database.transaction {
            from(Accounts)
                .where { Accounts.name eq "Test Account" }
                .fetchFirst { row ->
                    AccountData(
                        id = row[Accounts.id]!!,
                        name = row[Accounts.name]!!,
                        balance = row[Accounts.balance]!!
                    )
                }
        }

        assertEquals("Test Account", account?.name)
        assertEquals(java.math.BigDecimal("100.00"), account?.balance)
    }

    @Test
    fun `transaction rolls back on exception`(database: JdbcDatabase) {
        assertThrows<RuntimeException> {
            database.transaction {
                insertInto(Accounts) {
                    set(Accounts.name, "Failed Account")
                    set(Accounts.balance, java.math.BigDecimal("100.00"))
                }.execute()
                throw RuntimeException("Simulated failure")
            }
        }

        val account = database.transaction {
            from(Accounts)
                .where { Accounts.name eq "Failed Account" }
                .fetchFirst { row ->
                    AccountData(
                        id = row[Accounts.id]!!,
                        name = row[Accounts.name]!!,
                        balance = row[Accounts.balance]!!
                    )
                }
        }

        // Should not exist due to rollback
        assertNull(account)
    }

    @Test
    fun `multiple operations in transaction`(database: JdbcDatabase) {
        database.transaction {
            insertInto(Accounts) {
                set(Accounts.name, "Account 1")
                set(Accounts.balance, java.math.BigDecimal("500.00"))
            }.execute()
            insertInto(Accounts) {
                set(Accounts.name, "Account 2")
                set(Accounts.balance, java.math.BigDecimal("300.00"))
            }.execute()
            insertInto(Accounts) {
                set(Accounts.name, "Account 3")
                set(Accounts.balance, java.math.BigDecimal("200.00"))
            }.execute()
        }

        val count = database.transaction {
            from(Accounts).count()
        }
        assertEquals(3L, count)
    }

    // ==================== Transfer Scenario Tests ====================

    @Test
    fun `successful money transfer`(database: JdbcDatabase) {
        // Setup initial accounts
        val fromId = database.transaction {
            insertInto(Accounts) {
                set(Accounts.name, "Sender")
                set(Accounts.balance, java.math.BigDecimal("1000.00"))
            }.executeAndGetId()
        }
        val toId = database.transaction {
            insertInto(Accounts) {
                set(Accounts.name, "Receiver")
                set(Accounts.balance, java.math.BigDecimal("500.00"))
            }.executeAndGetId()
        }

        val transferAmount = java.math.BigDecimal("250.00")

        // Perform transfer in transaction
        database.transaction {
            // Debit from sender
            update(Accounts)
                .set(Accounts.balance, java.math.BigDecimal("750.00"))
                .where { Accounts.id eq fromId }
                .execute()

            // Credit to receiver
            update(Accounts)
                .set(Accounts.balance, java.math.BigDecimal("750.00"))
                .where { Accounts.id eq toId }
                .execute()

            // Log transfer
            insertInto(TransferLog) {
                set(TransferLog.fromAccount, fromId)
                set(TransferLog.toAccount, toId)
                set(TransferLog.amount, transferAmount)
            }.execute()
        }

        // Verify balances
        val sender = database.transaction {
            from(Accounts).where { Accounts.id eq fromId }.fetchFirst { row ->
                AccountData(row[Accounts.id]!!, row[Accounts.name]!!, row[Accounts.balance]!!)
            }!!
        }
        val receiver = database.transaction {
            from(Accounts).where { Accounts.id eq toId }.fetchFirst { row ->
                AccountData(row[Accounts.id]!!, row[Accounts.name]!!, row[Accounts.balance]!!)
            }!!
        }

        assertEquals(java.math.BigDecimal("750.00"), sender.balance)
        assertEquals(java.math.BigDecimal("750.00"), receiver.balance)

        // Verify log
        val logs = database.transaction {
            from(TransferLog).count()
        }
        assertEquals(1L, logs)
    }

    @Test
    fun `failed transfer rolls back all changes`(database: JdbcDatabase) {
        val fromId = database.transaction {
            insertInto(Accounts) {
                set(Accounts.name, "Sender")
                set(Accounts.balance, java.math.BigDecimal("100.00"))
            }.executeAndGetId()
        }
        val toId = database.transaction {
            insertInto(Accounts) {
                set(Accounts.name, "Receiver")
                set(Accounts.balance, java.math.BigDecimal("50.00"))
            }.executeAndGetId()
        }

        assertThrows<IllegalStateException> {
            database.transaction {
                // Debit from sender (this would make balance negative)
                update(Accounts)
                    .set(Accounts.balance, java.math.BigDecimal("-150.00"))
                    .where { Accounts.id eq fromId }
                    .execute()

                // Check balance validity (should throw)
                val senderBalance = from(Accounts).where { Accounts.id eq fromId }.fetchFirst { row ->
                    row[Accounts.balance]!!
                }!!
                if (senderBalance < java.math.BigDecimal.ZERO) {
                    throw IllegalStateException("Insufficient funds")
                }

                // This should never be reached
                update(Accounts)
                    .set(Accounts.balance, java.math.BigDecimal("300.00"))
                    .where { Accounts.id eq toId }
                    .execute()
            }
        }

        // Verify original balances are preserved
        val sender = database.transaction {
            from(Accounts).where { Accounts.id eq fromId }.fetchFirst { row ->
                AccountData(row[Accounts.id]!!, row[Accounts.name]!!, row[Accounts.balance]!!)
            }!!
        }
        val receiver = database.transaction {
            from(Accounts).where { Accounts.id eq toId }.fetchFirst { row ->
                AccountData(row[Accounts.id]!!, row[Accounts.name]!!, row[Accounts.balance]!!)
            }!!
        }

        assertEquals(java.math.BigDecimal("100.00"), sender.balance)
        assertEquals(java.math.BigDecimal("50.00"), receiver.balance)
    }

    // ==================== Isolation and Consistency Tests ====================

    @Test
    fun `read committed isolation`(database: JdbcDatabase) {
        val id = database.transaction {
            insertInto(Accounts) {
                set(Accounts.name, "Isolation Test")
                set(Accounts.balance, java.math.BigDecimal("100.00"))
            }.executeAndGetId()
        }

        // Within transaction, updates are visible
        database.transaction {
            update(Accounts)
                .set(Accounts.balance, java.math.BigDecimal("200.00"))
                .where { Accounts.id eq id }
                .execute()

            val balance = from(Accounts).where { Accounts.id eq id }.fetchFirst { row ->
                row[Accounts.balance]!!
            }!!
            assertEquals(java.math.BigDecimal("200.00"), balance)
        }

        // After commit, update is persisted
        val balance = database.transaction {
            from(Accounts).where { Accounts.id eq id }.fetchFirst { row ->
                row[Accounts.balance]!!
            }!!
        }
        assertEquals(java.math.BigDecimal("200.00"), balance)
    }

    @Test
    fun `transaction returns result`(database: JdbcDatabase) {
        val result = database.transaction {
            val id = insertInto(Accounts) {
                set(Accounts.name, "Return Test")
                set(Accounts.balance, java.math.BigDecimal("500.00"))
            }.executeAndGetId()
            id
        }

        assertTrue(result > 0)

        val account = database.transaction {
            from(Accounts).where { Accounts.id eq result }.fetchFirst { row ->
                AccountData(row[Accounts.id]!!, row[Accounts.name]!!, row[Accounts.balance]!!)
            }
        }
        assertEquals("Return Test", account?.name)
    }

    // ==================== Edge Cases ====================

    @Test
    fun `empty transaction commits successfully`(database: JdbcDatabase) {
        database.transaction {
            // No operations
        }
        // Should complete without error
        assertTrue(true)
    }

    @Test
    fun `read-only operations in transaction`(database: JdbcDatabase) {
        database.transaction {
            insertInto(Accounts) {
                set(Accounts.name, "Read Only Test")
                set(Accounts.balance, java.math.BigDecimal("100.00"))
            }.execute()
        }

        val result = database.transaction {
            from(Accounts).count()
        }

        assertEquals(1L, result)
    }

    @Test
    fun `transaction with multiple table operations`(database: JdbcDatabase) {
        database.transaction {
            val id1 = insertInto(Accounts) {
                set(Accounts.name, "Account A")
                set(Accounts.balance, java.math.BigDecimal("1000.00"))
            }.executeAndGetId()

            val id2 = insertInto(Accounts) {
                set(Accounts.name, "Account B")
                set(Accounts.balance, java.math.BigDecimal("500.00"))
            }.executeAndGetId()

            // Log a transfer between them
            insertInto(TransferLog) {
                set(TransferLog.fromAccount, id1)
                set(TransferLog.toAccount, id2)
                set(TransferLog.amount, java.math.BigDecimal("100.00"))
            }.execute()
        }

        val accountCount = database.transaction {
            from(Accounts).count()
        }
        val logCount = database.transaction {
            from(TransferLog).count()
        }

        assertEquals(2L, accountCount)
        assertEquals(1L, logCount)
    }
}
