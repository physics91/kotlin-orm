package com.physics91.korma.test.integration

import com.physics91.korma.dsl.*
import com.physics91.korma.jdbc.JdbcDatabase
import com.physics91.korma.schema.Table
import com.physics91.korma.test.DatabaseTest
import com.physics91.korma.test.DatabaseType
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import kotlin.test.assertEquals
import kotlin.test.assertNotNull
import kotlin.test.assertNull
import kotlin.test.assertTrue

/**
 * Integration tests for CRUD (Create, Read, Update, Delete) operations.
 * Tests the full lifecycle of database operations using the Korma DSL.
 */
@DatabaseTest(DatabaseType.H2)
class CrudIntegrationTest {

    // Data class for mapping
    data class UserData(
        val id: Long,
        val username: String,
        val email: String?,
        val age: Int?,
        val active: Boolean
    )

    // Test table definition
    object Users : Table("users") {
        val id = long("id").primaryKey().autoIncrement()
        val username = varchar("username", 50)
        val email = varchar("email", 100).nullable()
        val age = integer("age").nullable()
        val active = boolean("active")
    }

    @BeforeEach
    fun setup(database: JdbcDatabase) {
        // Create table (use quoted lowercase identifiers for H2 PostgreSQL mode compatibility)
        database.executeRaw("""
            CREATE TABLE IF NOT EXISTS "users" (
                "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "username" VARCHAR(50) NOT NULL,
                "email" VARCHAR(100),
                "age" INT,
                "active" BOOLEAN NOT NULL DEFAULT TRUE
            )
        """.trimIndent())

        // Clear existing data
        database.executeRaw("""DELETE FROM "users"""")
    }

    private fun mapUser(row: com.physics91.korma.jdbc.Row): UserData =
        UserData(
            id = row[Users.id]!!,
            username = row[Users.username]!!,
            email = row[Users.email],
            age = row[Users.age],
            active = row[Users.active]!!
        )

    // ==================== INSERT Tests ====================

    @Test
    fun `insert single record`(database: JdbcDatabase) {
        val result = database.transaction {
            insertInto(Users) {
                set(Users.username, "john_doe")
                set(Users.email, "john@example.com")
                set(Users.age, 25)
                set(Users.active, true)
            }.execute()
        }

        assertTrue(result > 0)
    }

    @Test
    fun `insert and retrieve generated key`(database: JdbcDatabase) {
        val id = database.transaction {
            insertInto(Users) {
                set(Users.username, "jane_doe")
                set(Users.email, "jane@example.com")
                set(Users.active, true)
            }.executeAndGetId()
        }

        assertNotNull(id)
        assertTrue(id > 0)

        // Verify the record exists
        val user = database.transaction {
            from(Users)
                .where { Users.id eq id }
                .fetchFirst { mapUser(it) }
        }

        assertNotNull(user)
        assertEquals("jane_doe", user.username)
    }

    @Test
    fun `insert with null values`(database: JdbcDatabase) {
        val id = database.transaction {
            insertInto(Users) {
                set(Users.username, "no_email_user")
                set(Users.email, null)
                set(Users.age, null)
                set(Users.active, false)
            }.executeAndGetId()
        }

        val user = database.transaction {
            from(Users)
                .where { Users.id eq id }
                .fetchFirst { mapUser(it) }
        }

        assertNotNull(user)
        assertNull(user.email)
        assertNull(user.age)
    }

    @Test
    fun `batch insert multiple records`(database: JdbcDatabase) {
        val users = listOf(
            Triple("user1", "user1@example.com", 20),
            Triple("user2", "user2@example.com", 25),
            Triple("user3", "user3@example.com", 30)
        )

        database.transaction {
            batchInsertInto(Users, users) { user ->
                set(Users.username, user.first)
                set(Users.email, user.second)
                set(Users.age, user.third)
                set(Users.active, true)
            }.execute()
        }

        val count = database.transaction {
            from(Users).count()
        }
        assertEquals(3, count)
    }

    // ==================== SELECT Tests ====================

    @Test
    fun `select all records`(database: JdbcDatabase) {
        // Insert test data
        repeat(5) { i ->
            database.transaction {
                insertInto(Users) {
                    set(Users.username, "user_$i")
                    set(Users.active, true)
                }.execute()
            }
        }

        val count = database.transaction {
            from(Users).count()
        }

        assertEquals(5, count)
    }

    @Test
    fun `select with where clause`(database: JdbcDatabase) {
        database.transaction {
            insertInto(Users) {
                set(Users.username, "active_user")
                set(Users.active, true)
            }.execute()
            insertInto(Users) {
                set(Users.username, "inactive_user")
                set(Users.active, false)
            }.execute()
        }

        val activeUsers = database.transaction {
            from(Users)
                .where { Users.active eq true }
                .fetch { mapUser(it) }
        }

        assertEquals(1, activeUsers.size)
        assertEquals("active_user", activeUsers.first().username)
    }

    @Test
    fun `select with multiple conditions`(database: JdbcDatabase) {
        database.transaction {
            insertInto(Users) {
                set(Users.username, "young_active")
                set(Users.age, 20)
                set(Users.active, true)
            }.execute()
            insertInto(Users) {
                set(Users.username, "old_active")
                set(Users.age, 50)
                set(Users.active, true)
            }.execute()
            insertInto(Users) {
                set(Users.username, "young_inactive")
                set(Users.age, 20)
                set(Users.active, false)
            }.execute()
        }

        val result = database.transaction {
            from(Users)
                .where { (Users.age gt 25) and (Users.active eq true) }
                .fetch { mapUser(it) }
        }

        assertEquals(1, result.size)
        assertEquals("old_active", result.first().username)
    }

    @Test
    fun `select with order by`(database: JdbcDatabase) {
        database.transaction {
            insertInto(Users) { set(Users.username, "charlie"); set(Users.active, true) }.execute()
            insertInto(Users) { set(Users.username, "alice"); set(Users.active, true) }.execute()
            insertInto(Users) { set(Users.username, "bob"); set(Users.active, true) }.execute()
        }

        val sorted = database.transaction {
            from(Users)
                .orderBy(Users.username.asc())
                .fetch { mapUser(it) }
        }

        assertEquals("alice", sorted[0].username)
        assertEquals("bob", sorted[1].username)
        assertEquals("charlie", sorted[2].username)
    }

    @Test
    fun `select with limit and offset`(database: JdbcDatabase) {
        database.transaction {
            repeat(10) { i ->
                insertInto(Users) {
                    set(Users.username, "user_${i.toString().padStart(2, '0')}")
                    set(Users.active, true)
                }.execute()
            }
        }

        val page = database.transaction {
            from(Users)
                .orderBy(Users.username.asc())
                .limit(3)
                .offset(3)
                .fetch { mapUser(it) }
        }

        assertEquals(3, page.size)
        assertEquals("user_03", page[0].username)
        assertEquals("user_04", page[1].username)
        assertEquals("user_05", page[2].username)
    }

    @Test
    fun `select specific columns`(database: JdbcDatabase) {
        database.transaction {
            insertInto(Users) {
                set(Users.username, "test_user")
                set(Users.email, "test@example.com")
                set(Users.age, 30)
                set(Users.active, true)
            }.execute()
        }

        val result = database.transaction {
            from(Users)
                .select(Users.username, Users.email)
                .fetchFirst { row ->
                    Pair(row[Users.username], row[Users.email])
                }
        }

        assertNotNull(result)
        assertEquals("test_user", result.first)
        assertEquals("test@example.com", result.second)
    }

    @Test
    fun `select with like operator`(database: JdbcDatabase) {
        database.transaction {
            insertInto(Users) { set(Users.username, "john_smith"); set(Users.active, true) }.execute()
            insertInto(Users) { set(Users.username, "john_doe"); set(Users.active, true) }.execute()
            insertInto(Users) { set(Users.username, "jane_doe"); set(Users.active, true) }.execute()
        }

        val johns = database.transaction {
            from(Users)
                .where { Users.username like "john%" }
                .fetch { mapUser(it) }
        }

        assertEquals(2, johns.size)
    }

    @Test
    fun `select with in operator`(database: JdbcDatabase) {
        database.transaction {
            insertInto(Users) { set(Users.username, "user_a"); set(Users.age, 20); set(Users.active, true) }.execute()
            insertInto(Users) { set(Users.username, "user_b"); set(Users.age, 25); set(Users.active, true) }.execute()
            insertInto(Users) { set(Users.username, "user_c"); set(Users.age, 30); set(Users.active, true) }.execute()
            insertInto(Users) { set(Users.username, "user_d"); set(Users.age, 35); set(Users.active, true) }.execute()
        }

        val result = database.transaction {
            from(Users)
                .where { Users.age inList listOf(20, 30) }
                .fetch { mapUser(it) }
        }

        assertEquals(2, result.size)
    }

    @Test
    fun `select with is null`(database: JdbcDatabase) {
        database.transaction {
            insertInto(Users) { set(Users.username, "with_email"); set(Users.email, "a@b.com"); set(Users.active, true) }.execute()
            insertInto(Users) { set(Users.username, "no_email"); set(Users.email, null); set(Users.active, true) }.execute()
        }

        val noEmail = database.transaction {
            from(Users)
                .where { Users.email.isNull() }
                .fetch { mapUser(it) }
        }

        assertEquals(1, noEmail.size)
        assertEquals("no_email", noEmail.first().username)
    }

    // ==================== UPDATE Tests ====================

    @Test
    fun `update single record`(database: JdbcDatabase) {
        val id = database.transaction {
            insertInto(Users) {
                set(Users.username, "original")
                set(Users.active, true)
            }.executeAndGetId()
        }

        val updated = database.transaction {
            update(Users)
                .set(Users.username, "updated")
                .where { Users.id eq id }
                .execute()
        }

        assertEquals(1, updated)

        val user = database.transaction {
            from(Users)
                .where { Users.id eq id }
                .fetchFirst { mapUser(it) }
        }

        assertEquals("updated", user!!.username)
    }

    @Test
    fun `update multiple fields`(database: JdbcDatabase) {
        val id = database.transaction {
            insertInto(Users) {
                set(Users.username, "old_name")
                set(Users.email, "old@email.com")
                set(Users.age, 20)
                set(Users.active, true)
            }.executeAndGetId()
        }

        database.transaction {
            update(Users)
                .set(Users.username, "new_name")
                .set(Users.email, "new@email.com")
                .set(Users.age, 25)
                .where { Users.id eq id }
                .execute()
        }

        val user = database.transaction {
            from(Users)
                .where { Users.id eq id }
                .fetchFirst { mapUser(it) }!!
        }

        assertEquals("new_name", user.username)
        assertEquals("new@email.com", user.email)
        assertEquals(25, user.age)
    }

    @Test
    fun `update multiple records with condition`(database: JdbcDatabase) {
        database.transaction {
            repeat(5) { i ->
                insertInto(Users) {
                    set(Users.username, "user_$i")
                    set(Users.active, i % 2 == 0)
                }.execute()
            }
        }

        val updated = database.transaction {
            update(Users)
                .set(Users.active, true)
                .where { Users.active eq false }
                .execute()
        }

        assertEquals(2, updated)

        val allActive = database.transaction {
            from(Users)
                .where { Users.active eq true }
                .count()
        }

        assertEquals(5, allActive)
    }

    // ==================== DELETE Tests ====================

    @Test
    fun `delete single record`(database: JdbcDatabase) {
        val id = database.transaction {
            insertInto(Users) {
                set(Users.username, "to_delete")
                set(Users.active, true)
            }.executeAndGetId()
        }

        val deleted = database.transaction {
            deleteFrom(Users)
                .where { Users.id eq id }
                .execute()
        }

        assertEquals(1, deleted)

        val user = database.transaction {
            from(Users)
                .where { Users.id eq id }
                .fetchFirst { mapUser(it) }
        }

        assertNull(user)
    }

    @Test
    fun `delete with condition`(database: JdbcDatabase) {
        database.transaction {
            repeat(5) { i ->
                insertInto(Users) {
                    set(Users.username, "user_$i")
                    set(Users.active, i < 2)
                }.execute()
            }
        }

        val deleted = database.transaction {
            deleteFrom(Users)
                .where { Users.active eq false }
                .execute()
        }

        assertEquals(3, deleted)

        val remaining = database.transaction {
            from(Users).count()
        }
        assertEquals(2, remaining)
    }

    @Test
    fun `delete all records`(database: JdbcDatabase) {
        database.transaction {
            repeat(5) { i ->
                insertInto(Users) {
                    set(Users.username, "user_$i")
                    set(Users.active, true)
                }.execute()
            }
        }

        val deleted = database.transaction {
            deleteFrom(Users).execute()
        }

        assertEquals(5, deleted)

        val remaining = database.transaction {
            from(Users).count()
        }
        assertEquals(0, remaining)
    }

    // ==================== Count/Aggregate Tests ====================

    @Test
    fun `count records`(database: JdbcDatabase) {
        database.transaction {
            repeat(7) { i ->
                insertInto(Users) {
                    set(Users.username, "user_$i")
                    set(Users.active, true)
                }.execute()
            }
        }

        val count = database.transaction {
            from(Users).count()
        }
        assertEquals(7L, count)
    }

    @Test
    fun `exists check`(database: JdbcDatabase) {
        database.transaction {
            insertInto(Users) {
                set(Users.username, "existing_user")
                set(Users.active, true)
            }.execute()
        }

        val exists = database.transaction {
            from(Users)
                .where { Users.username eq "existing_user" }
                .exists()
        }

        val notExists = database.transaction {
            from(Users)
                .where { Users.username eq "non_existing" }
                .exists()
        }

        assertTrue(exists)
        assertTrue(!notExists)
    }
}
