package com.physics91.korma.test.stress

import com.physics91.korma.dsl.*
import com.physics91.korma.jdbc.JdbcDatabase
import com.physics91.korma.schema.Table
import com.physics91.korma.test.DatabaseTest
import com.physics91.korma.test.DatabaseType
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import java.math.BigDecimal
import kotlin.test.assertTrue

/**
 * Tests for memory leaks in long-running database operations.
 * Verifies that resources are properly released after operations.
 */
@DatabaseTest(DatabaseType.H2)
class MemoryLeakTest {

    object LeakTestItems : Table("leak_test_items") {
        val id = long("id").primaryKey().autoIncrement()
        val data = varchar("data", 500)
        val value = decimal("value", 10, 2)
    }

    @BeforeEach
    fun setup(database: JdbcDatabase) {
        database.executeRaw("""
            CREATE TABLE IF NOT EXISTS "leak_test_items" (
                "id" BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                "data" VARCHAR(500) NOT NULL,
                "value" DECIMAL(10, 2) NOT NULL DEFAULT 0
            )
        """.trimIndent())
        database.executeRaw("""DELETE FROM "leak_test_items"""")

        // Force GC before tests
        System.gc()
        Thread.sleep(100)
    }

    @Test
    fun `repeated transactions do not leak memory`(database: JdbcDatabase) {
        val iterations = 1000
        val initialMemory = getUsedMemory()

        repeat(iterations) { i ->
            database.transaction {
                insertInto(LeakTestItems) {
                    set(LeakTestItems.data, "Test data for iteration $i - " + "x".repeat(100))
                    set(LeakTestItems.value, BigDecimal("${i}.99"))
                }.execute()
            }

            // Periodically run GC to observe memory behavior
            if (i % 100 == 0) {
                System.gc()
            }
        }

        // Force final GC
        System.gc()
        Thread.sleep(200)

        val finalMemory = getUsedMemory()
        val memoryGrowth = finalMemory - initialMemory

        // Verify records were created
        val count = database.transaction {
            from(LeakTestItems).count()
        }
        assertTrue(count == iterations.toLong(), "All records should be inserted")

        // Memory growth should be reasonable (allowing for cached connections and data)
        // Note: This is a heuristic check, not a strict limit
        val maxExpectedGrowthMB = 100L
        assertTrue(
            memoryGrowth < maxExpectedGrowthMB * 1024 * 1024,
            "Memory growth ($memoryGrowth bytes) should be under ${maxExpectedGrowthMB}MB"
        )
    }

    @Test
    fun `large result set fetching releases memory`(database: JdbcDatabase) {
        // Insert large dataset
        database.transaction {
            val items = (0 until 1000).map { i ->
                "Large data item $i - " + "x".repeat(200) to BigDecimal("$i.00")
            }
            batchInsertInto(LeakTestItems, items) { (data, value) ->
                set(LeakTestItems.data, data)
                set(LeakTestItems.value, value)
            }.execute()
        }

        System.gc()
        val memoryBefore = getUsedMemory()

        // Fetch and process large result sets multiple times
        repeat(10) {
            val results = database.transaction {
                from(LeakTestItems)
                    .fetch { row ->
                        Pair(row[LeakTestItems.data]!!, row[LeakTestItems.value]!!)
                    }
            }
            // Process results
            assertTrue(results.size == 1000, "Should fetch all records")

            // Clear reference
            @Suppress("UNUSED_VALUE")
            var unused: List<Pair<String, BigDecimal>>? = results
            unused = null
        }

        System.gc()
        Thread.sleep(200)
        val memoryAfter = getUsedMemory()

        // Memory should not grow significantly after releasing results
        val growth = memoryAfter - memoryBefore
        val maxGrowthMB = 50L
        assertTrue(
            growth < maxGrowthMB * 1024 * 1024,
            "Memory after fetching ($growth bytes) should stabilize"
        )
    }

    @Test
    fun `rapid query creation does not accumulate objects`(database: JdbcDatabase) {
        // Insert some test data
        database.transaction {
            repeat(100) { i ->
                insertInto(LeakTestItems) {
                    set(LeakTestItems.data, "Query test $i")
                    set(LeakTestItems.value, BigDecimal("$i.00"))
                }.execute()
            }
        }

        System.gc()
        val initialMemory = getUsedMemory()

        // Create and execute many queries
        repeat(5000) { i ->
            database.transaction {
                from(LeakTestItems)
                    .where { LeakTestItems.value gt BigDecimal("${i % 50}.00") }
                    .limit(10)
                    .fetch { row -> row[LeakTestItems.id] }
            }
        }

        System.gc()
        Thread.sleep(200)
        val finalMemory = getUsedMemory()

        val growth = finalMemory - initialMemory
        val maxGrowthMB = 30L
        assertTrue(
            growth < maxGrowthMB * 1024 * 1024,
            "Query objects should be garbage collected"
        )
    }

    @Test
    fun `exception paths properly release resources`(database: JdbcDatabase) {
        System.gc()
        val initialMemory = getUsedMemory()

        repeat(500) { i ->
            try {
                database.transaction {
                    insertInto(LeakTestItems) {
                        set(LeakTestItems.data, "Exception test $i")
                        set(LeakTestItems.value, BigDecimal("$i.00"))
                    }.execute()

                    // Throw exception to trigger rollback
                    if (i % 2 == 0) {
                        throw RuntimeException("Simulated exception")
                    }
                }
            } catch (e: RuntimeException) {
                // Expected exception
            }
        }

        System.gc()
        Thread.sleep(200)
        val finalMemory = getUsedMemory()

        // Verify half were inserted (those that didn't throw)
        val count = database.transaction {
            from(LeakTestItems).count()
        }
        assertTrue(count >= 200, "Successful transactions should commit")

        val growth = finalMemory - initialMemory
        val maxGrowthMB = 30L
        assertTrue(
            growth < maxGrowthMB * 1024 * 1024,
            "Exception paths should not leak memory"
        )
    }

    @Test
    fun `long running session stability`(database: JdbcDatabase) {
        val sessionDuration = 5000L // 5 seconds
        val startTime = System.currentTimeMillis()
        var operationCount = 0

        System.gc()
        val initialMemory = getUsedMemory()

        while (System.currentTimeMillis() - startTime < sessionDuration) {
            database.transaction {
                insertInto(LeakTestItems) {
                    set(LeakTestItems.data, "Session test ${operationCount++}")
                    set(LeakTestItems.value, BigDecimal("${operationCount}.00"))
                }.execute()
            }

            // Mix of reads and writes
            if (operationCount % 10 == 0) {
                database.transaction {
                    from(LeakTestItems)
                        .orderBy(LeakTestItems.id.desc())
                        .limit(10)
                        .fetch { row -> row[LeakTestItems.id] }
                }
            }

            // Periodic GC
            if (operationCount % 100 == 0) {
                System.gc()
            }
        }

        System.gc()
        Thread.sleep(200)
        val finalMemory = getUsedMemory()

        val count = database.transaction {
            from(LeakTestItems).count()
        }

        assertTrue(count > 0, "Operations should have committed")
        assertTrue(operationCount > 100, "Should have performed many operations")

        val growth = finalMemory - initialMemory
        val maxGrowthMB = 50L
        assertTrue(
            growth < maxGrowthMB * 1024 * 1024,
            "Long session should not accumulate memory (growth: ${growth / 1024 / 1024}MB)"
        )
    }

    @Test
    fun `batch operations memory efficiency`(database: JdbcDatabase) {
        System.gc()
        val initialMemory = getUsedMemory()

        // Insert large batches multiple times
        repeat(10) { batchNum ->
            val items = (0 until 500).map { i ->
                "Batch $batchNum item $i - " + "x".repeat(100) to BigDecimal("${i}.00")
            }

            database.transaction {
                batchInsertInto(LeakTestItems, items) { (data, value) ->
                    set(LeakTestItems.data, data)
                    set(LeakTestItems.value, value)
                }.execute()
            }

            System.gc()
        }

        System.gc()
        Thread.sleep(200)
        val finalMemory = getUsedMemory()

        val count = database.transaction {
            from(LeakTestItems).count()
        }
        assertTrue(count == 5000L, "All batch items should be inserted")

        val growth = finalMemory - initialMemory
        val maxGrowthMB = 50L
        assertTrue(
            growth < maxGrowthMB * 1024 * 1024,
            "Batch operations should be memory efficient"
        )
    }

    private fun getUsedMemory(): Long {
        val runtime = Runtime.getRuntime()
        return runtime.totalMemory() - runtime.freeMemory()
    }
}
